# 主从复制是如何实现的？
数据存储在一台服务器会出现的问题
- 如果服务器发生宕机，恢复数据期间无法服务新的请求
- 服务器硬盘出现了故障，数据全部丢失
通过主从复制避免上面的问题，主从服务器之间采用读写分离的方式
## 第一次同步
三个阶段：
1. 建立链接，协商同步
	1. 从服务器发送psync命令，分别是主服务器的runID和复制进度offset
2. 主服务器同步数据给从服务器
	1. 生成一个子进程执行这个操作
	2. 新的写操作命令在下面这些间隙写入到relplication buffer这个缓冲区里
		1. 主服务器生成RDB文件期间
		2. 主服务器发送RDB文件期间
		3. 从服务器加载RDB文件期间
3. 主服务器发送新的写操作命令给从服务器
	1. 从服务器加载好RDB文件，发送一个确认消息，主服务器将replication buffer 发送给从服务器，从服务器进行同步
## 命令传播
第一次同步后，主从服务器维持一个TCP长连接，主服务器通过这个连接将写操作命令传播给从服务器，从服务器同步
## 分摊主服务器的压力
- fork()函数占用主线程资源，使得redis无法响应请求
- 传输RDB占用主服务器网络带宽，影响主服务器命令响应
创建从服务器的从服务器
## 增量复制
主从之间的网络突然断开，如果这是重连成功，从效率上来讲，就需要进行增量复制，从断开连接前最后一条没有同步的写命令操作开始，避免RDB的全量传输，占用资源
过程：
- 从服务器发送psync命令，携带slace_repl_offset参数，指示从服务器此时读到那个参数
- 主服务器收到该命令后，用continue响应命令告诉从服务器接下来采用增量复制的方式同步数据
- 主服务器将短线期间的写命令发送给从服务端

如何确定要将哪些数据发送到从服务器？
- repl_backlog_buffer , 是一个环形缓冲区，用于主从服务器断连后，从中找到差异的数据
- replication_offset,标记上面那个缓存区的同步进度，master_repl_offset标记主服务器写到的位置

repl_backlog_buffer 保存着最近传播的写命令

当从服务器将自己的slace_repl_offset发送来后：
- 如果从服务器要读取的数据还在buffer中，增量复制，将数据写入replication buffer ，等待发送给从库
- 相反，如果判断出从服务器要读取的数据不在，全量复制

为了减少全量同步频率，尽可能让repl_backlog_buffer大
根据此公式
 second * write_size_pre_second
- secong为平均断线重连时间
- 后者为每秒平均写命令操作数据量
## 面试题
### Redis主从连接是长连接还是短链接？
### 怎么判断Redis某个节点是否正常工作？
### 主从复制架构中，过期Key如何处理？
### Redis是同步复制还是异步复制？
### 主从复制中两个Buffer有什么区别？
### 如何应对主从数据不一致？
为什么会主从不一致
如何应对
### 主从切换如何减少数据丢失？
两种情况：
- 异步复制同步丢失
- 集群脑裂产生数据丢失
# 哨兵机制
## 为什么要有哨兵机制？
哨兵机制实现主从故障转移。它会监测主节点是否存活，如果发现主节点挂了，他就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端
## 哨兵机制是如何工作的？
==监控、选主、通知==
## 如何判断主节点真的故障了？
哨兵每隔一秒向所有主从节点发送ping命令，节点收到ping命令，回复一个响应命令

如果在规定时间内没有响应，哨兵将他们标记为**主观下线**

**客观下线**专属于主节点，由哨兵集群判断，哨兵的赞同数超过quorum后，主节点被判断为客观下线

- 避免单个哨兵因为自身网络不好，误判主节点下线的情况
## 由哪个哨兵进行主从故障转移？
投票从候选人中选出leader

候选者：判断主节点客观下线的那个节点

leader条件：
- 拿到半数以上的赞成票
- 票数大一等于哨兵配置文件中的quorum值
所有节点只有一票，可以投给自己，候选者默认投给自己

哨兵节点的数量应该是奇数，的值建议设置为哨兵数量的二分之一减一
## 主从故障转移过程是怎样的？
四个步骤：
1. 选择一个从节点变为主节点
2. 将其他主节点的复制目标修改为新的主节点
3. 将主节点的IP地址和信息，通过发布订阅机制通知给客户端
4. 监控旧的主节点，旧的主节点上线后，将他设置为新主节点的从节点
### 步骤一：选出新主节点
首先过滤掉网络连接不好的从节点
对剩余的节点进行三轮考察：
- 优先级
- 复制进度
- ID号
**第一轮考察：优先级最高的节点胜出**
优先级手动配置
**第二轮考察：复制进度最靠前的从节点胜出**
谁的slave_repl_offset 和 master_repl_offset 更靠近
**第三轮考察：ID号小的从节点胜出**

哨兵向选中的节点发送`slaveof no one`命令，使其变为主节点

### 步骤二：将从节点指向新主节点
向所有从节点发送`SLAVEOF`命令

### 步骤三：通知客户主节点已更换
客户端订阅哨兵提供的消息频道

主从切换完成后，向`+switch-master` 发布新节点的IP地址和客户端消息

### 步骤四：将旧节点变为从节点
当旧的主节点重新上线时，向他发送`SLAVEOF`命令，让它成为新主节点的从节点
## 哨兵集群是如何组成的？
主节点上有一个`_sentinel_:hello`频道，哨兵们通过订约这个集群获得彼此之间的IP地址和端口号

主节点知道所有从节点的信息，哨兵通过十秒一次的频率向主节点发送INFO命令获得所有从节点的信息

# Cluster集群

## 为什么需要Redis Cluster？
- 主从模式每个节点存储的数据是相同的，浪费内存，并且不好在线扩容
- Cluster模式每台Redis储存不同的内容，来解决在线扩容的问题，并且，它可以保存大量的数据，既能分散数据到各个Redis实例，还提供复制和故障转移的功能。
## 客户端怎样确定应该访问的分片？（哈希槽）
一个切片集群被分为16382个slot，每个进入Redis的键值对，根据Key进行散列，非陪这16384插槽中的一个。
使用Hash映射的方法：用==CRC16==算法计算出一个16bit的值，再对16384取模。
N个集群每个集群管理 16384 / N 个slot
## 实例上没有相对应的数据，会怎么样？（MOVED重定向和ASK重定向）
在Redis Cluster 模式下，节点对请求的处理过程如下：
1. 通过哈希槽映射，检查当前Redis Key 是否存在当前节点
2. 若哈希槽不是由自身节点负责，就返回MOVED重定向
3. 若哈希槽确实由自身负责，且key在slot中，则返回该key对应的结果
4. 若Redis Key 不存在此哈希槽中，检查该哈希槽是否正在迁出(MIGRATING)
5. 若Redis Key 正在迁出，返回ASK错误重定向客户端到迁移的目的服务器上
6. 若哈希槽未迁出，检查哈希槽是否导入中
7. 若哈希槽导入中且有ASKING标记，则直接操作，否则返回MOVED重定向
### Moved重定向
计算出来槽点不在该节点上，会返回MOVED重定向错误，MOVED重定向错误中，会携带新实例的IP和port端口。
### ASK重定向
发生于集群伸缩的时候
## 各个节点之间是怎样通信的呢？(Gossip)
每个节点周期性的从节点列表里选择K个节点，将本节点的信息传播出去，知道所有节点信息一致
- meet消息
- ping消息
- pong消息
- fail消息
## 集群内节点出现故障怎么办？
通过故障转移，保证集群正常对外提供服务
- 主观下线：一个集群判定
- 客观下线：多个集群判定
## 为什么哈希槽总数为16384？
