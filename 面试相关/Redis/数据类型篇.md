# Redis常见数据类型和使用场景
## String
Key-Value，Value啥都可以放，Value最大是512M
### 内部实现
有点复杂，总之使用一个SDS（Simple Dynamic String），有以下特点：
- 可以记录字符串的长度，获取字符串长度的时间复杂度为O(1)
- 可以自动扩容，字符串拼接时，空间不够会自动扩容
- 可以保存二进制数据，可以保存图片、音频、视频、压缩文件
```C
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len;        // 已使用的字节数（字符串长度）
    uint8_t alloc;      // 分配的总字节数（不包括头部和 \0）
    unsigned char flags; // 标志位，标识 header 类型（如 sdshdr8, sdshdr16 等）
    char buf[];         // 实际存储字符串的柔性数组（以 \0 结尾）
};
```
字符串的内部编码有三种；
1. int：整数类型
2. embtr:短一点
3. raw:长一点
emstr和raw都会通过SDS来保存值，不同之处是emstr会通过一次内存分配函数来分配一块连续的内存空间来保存redisObject和SDS，而raw编码会通过调用两次内存分配函数来分别分配两块空间保存redisObject和SDS。
- 应为embtr编码的字符串对象都保存在一块连续的内存里面可以更好的利用CPU缓存提升性能
- embtr实际上是只读的，所以对他修改时，都要先变成raw进行修改
### 应用场景
- 缓存对象
- 常规计数
- 分布式锁
	```SQL
	set lock_key unique_value NX PX 10000
	```
- 共享Session信息
## List
按照插入顺序排序，可以从头部和尾部向List列表插入元素
### 内部实现
双向列表或压缩列表实现，3.2之后使用quicklist
### 应用场景
#### 消息队列

##### 1.如何满足消息保存需求？
- 消息保存：使用LPUSH+RPOP
- 减少性能开销，使用BRPOP命令。阻塞式读取，客户端在没有读到队列数据是，自动阻塞，知道有新的数据写入队列，再开始读取新数据
##### 2.如何处理重复的消息
- 为每个消息手动创建一个全局唯一消息ID
- 记录处理完的消息
##### 3.如何保证消息的可靠性
使用BRPOPPUSH，在消费者读取这个消息的同时，把这个消息再插入到另外一个List留存
##### 4.List作为消息队列的缺陷？
- 不支持多个消费者消费同一个信息
- 不支持消费组的实现
Stream支持消费组形式
## Hash
Value里面又有field和value
### 内部实现
压缩表或哈希表，redis7.0，由listpack实现
### 应用场景
#### 缓存对象
#### 购物车
## Set
无序并唯一的键值对集合，支持交并补集合运算
### 内部实现
如果是整数且元素个数小于512，使用整数集合；否则使用哈希表
### 应用场景
集合运算计算复杂度高，会导致Redis实例阻塞。选择一个从库完成聚合统计，或者返回数据给客户端，由客户端完成
##### 点赞
##### 共同关注
##### 抽奖活动
## Zset
增加一个score值，根据这个值进行排序
### 内部实现
压缩列表或跳表，redis7.0使用listpack实现
### 应用场景
#### 排行榜
#### 电话姓名排序
## BitMap
是一串连续的二进制数组，可以通过偏移量定位元素
### 内部实现
String 
### 应用场景
#### 签到统计
#### 判断用户登录状态
#### 连续签到用户总数
通过位运算
## HyperLogLog
提供不精确的去重计数
### 内部实现
过于复杂，不便展示
### 应用场景
#### 百万级网页UV计数
## GEO
记录地理信息，可以计算距离，查询范围内的目标
### 内部实现
Sorted Set
### 应用场景
#### 滴滴打车
#### 外卖配送、附近商家查询
## Stream
为消息队列而生
### 应用场景
#### 消息队列
- 消息保存：XADD/XREAD
- 阻塞读取：XREAD biock
- 重复消息处理：Stream使用XADD命令，会自动生成全局唯一ID
- 消息可靠性：内部使用PENDING List 自动保存信息，使用XPENDING命令查看消费组已经读取但是未确认的消息，消费者使用XACK确认消息
- 支持消费组形式消费数据
Stream的一些问题：
1. Redis消息中间件会丢失消息
	1. AOF阶段
	2. 主从复制
2. Redis消息中间件不能堆积
	1. Redis本身会丢失数据
	2. 面对消息挤压，内存资源会紧张
发布订阅机制为什么不当成消息队列使用？
- 不具备数据持久化的能力
- 发后即忘，重连之后消费者不能消费之前的消息
- 超过32M或8M持续60秒消费端会被强行断开

# Redis 数据结构
## 键值对数据库是怎样实现的？
哈希桶里面存放key和value的指针

void* key 和 void* value 指向的是Redis对象

## SDS
C语言String有缺陷：
- 遇到\0停止，不能存储文本，视频
- 获取长度时间复杂度为O(n)
- 拼接字符串容易溢出
SDS
```C
// 1. 最小 header：总长 3 字节（len=1B, alloc=1B, flags=1B）
struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char len; /* 3 位用于 len，5 位未使用（sdshdr5 已废弃，但保留） */
    unsigned char alloc; /* 高 5 位未使用 */
    unsigned char flags; /* 低 3 位必须是 000 */
    char buf[];          /* 柔性数组，存放实际字符串 + \0 */
};

// 2. 小字符串：总长 8 字节（len=2B, alloc=2B, flags=1B）
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len;         /* 字符串长度 */
    uint8_t alloc;       /* 分配的容量 */
    unsigned char flags; /* 低3位 = 001 */
    char buf[];
};

// 3. 中等字符串：总长 16 字节（len=4B, alloc=4B, flags=1B）
struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len;        /* 字符串长度 */
    uint16_t alloc;      /* 分配的容量 */
    unsigned char flags; /* 低3位 = 010 */
    char buf[];
};

// 4. 大字符串：总长 32 字节（len=8B, alloc=8B, flags=1B）
struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len;        /* 字符串长度 */
    uint32_t alloc;      /* 分配的容量 */
    unsigned char flags; /* 低3位 = 011 */
    char buf[];
};

// 5. 超大字符串（64位系统）：总长 64 字节（len=8B, alloc=8B, flags=1B）
struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len;        /* 字符串长度 */
    uint64_t alloc;      /* 分配的容量 */
    unsigned char flags; /* 低3位 = 100 */
    char buf[];
};
```

- len：记录字符串长度
- alloc：记录实际分配的空间长度
- flags：表示不同类型的SDS
- buf[]：字节数组存储实际的数据
SDS的自动扩容规则：
- 如果SDS小于1MB，翻倍执行
- 如果超过1MB，newlen + 1MB
扩容前会检查未使用空间是否足够，如果不够，除了分配必须的空间，还会分配额外的未使用空间

- Redis使用专门的编译优化，告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对其
## 链表
```C
//链表节点
typedef struct listNode {
    struct listNode *prev;   // 前驱指针
    struct listNode *next;   // 后继指针
    void *value;             // 节点存储的值（通用指针）
} listNode;

//链表主体
typedef struct list {
    listNode *head;          // 头节点
    listNode *tail;          // 尾节点
    void *(*dup)(void *ptr); // 节点值复制函数（可选）
    void (*free)(void *ptr); // 节点值释放函数（可选）
    int (*match)(void *ptr, void *key); // 节点值匹配函数（可选）
    unsigned long len;       // 链表长度（节点数）
} list;
```
优点：
- 获取前驱和后继的时间复杂度O(1)
- 获取头节点、尾节点的时间复杂度O(1)
- 获取链表节点数量的时间复杂度O(1)
- 链表节点可以存储不同类型的值
缺点：
- 节点在内存中不连续，无法有效利用CPU缓存
- 保存一个链表节点的值都需要一个链表节点结构头的分配，内存开销大
## 压缩列表
连续内存块组成的顺序型数据结构
整体布局
```text
+----------+----------+----------+----------+----------+----------+
| zlbytes  | zltail   | zllen    | entry[0] | entry[1] | ...      |
| (4 bytes)| (4 bytes)| (2 bytes)|          |          |          |
+----------+----------+----------+----------+----------+----------+
... +----------+----------+
    | entry[N] | zlend    |
    |          | (1 byte) |
    +----------+----------+
```
- zlbytes：整个 ziplist 占用的总字节数（含 header 和 zlend）
- zltail：最后一个 entry 的偏移量（用于 O(1) 从尾部插入）
- zllen：entry 数量（若 > 65535，则需遍历计算）
- zlend：固定值 0xFF（十进制为225），表示结束
entry构成
```text
+------------------+------------------+------------------+
| prevlen          | encoding         | data             |
+------------------+------------------+------------------+
```
- prelen：记录前一个entry的长度，用于实现从后往前遍历
- encoding：记录当前节点实际的类型和长度，类型主要有：字符串和整数
- data：记录当前节点的实际数据，类型和长度都由encoding决定
### 连锁更新
压缩链表某个元素更新或修改，如果重新分配内存空间，就会导致后续元素的prelen占用空间全部发生变化，导致每个元素的空间都要重新分配
### 压缩列表的缺陷
就是连锁更新，所以压缩列表只能用于节点数量不多的场景
## 哈希表
哈希表节点
```C
typedef struct dictEntry {
    void *key;                    // 键（通用指针）
    union {
        void *val;                // 值（通用指针）
        uint64_t u64;             // 用于存储整数（节省内存）
        int64_t s64;              // 有符号整数
        double d;                 // 浮点数
    } v;                          // 联合体：节省空间
    struct dictEntry *next;       // 链地址法解决冲突（单向链表）
} dictEntry;
```
哈希表主体
```C
typedef struct dictht {
    dictEntry **table;            // 指向数组的指针（每个元素是链表头）
    unsigned long size;           // 哈希表大小（桶数量，总是 2^n）
    unsigned long sizemask;       // 掩码 = size - 1（用于快速取模）
    unsigned long used;           // 已有节点数量
} dictht;
```
用链式哈希解决哈希冲突，但是随着链表长度的增加，在这一位置上的查询的耗时就会增加
### rehash
```C
typedef struct dict {
    dictType *type;               // 类型特定函数指针集合（见下文）
    void *privdata;               // 私有数据（传给 type 函数）
    dictht ht[2];                 // 两个哈希表：ht[0] 正常使用，ht[1] 用于 rehash
    long rehashidx;               // rehash 进度：-1 表示未 rehash，≥0 表示正在迁移 ht[0] 的第 rehashidx 个桶
    unsigned long iterators;      // 当前活跃的迭代器数量（防止 rehash 时破坏结构）
} dict;
```
rehash过程
- 给哈希表2分配空间，一般会比哈希表1大一倍
- 哈希表1的数据迁移到哈希表2中
- 迁移完成后，哈希表2会被设置成哈希表1，释放哈希表1的空间，然后在哈希表2新创建一个空白的哈希表
但是如果哈希表一的数据特别多，迁移也会费时间，可能会造成Redis阻塞，无法服务其他请求

渐进式Hash
- 给哈希表二分配空间
- 哈希表一中的数据被访问一次，Redis按顺序将哈希表一上的所有Key-Value迁移到哈希表2

- 渐进式Hash期间，会同时使用两个哈希表
- 新增元素会加入到哈希表2

rehash触发条件
```text
	 负载因子 = 哈希表已经保存数据节点 / 哈希表大小
```
- 当负载因子大于等于1，且没有执行RDB快照或进行AOF重写
- 当负载因子大于5时，强制执行rehash操作
## 整数集合
```C
typedef struct intset {
    uint32_t encoding;     // 编码方式：INTSET_ENC_INT16 / INT32 / INT64
    uint32_t length;       // 元素个数
    int8_t contents[];     // 柔性数组，实际存储整数（类型由 encoding 决定）
} intset;
```
整数集合的升级操作
- 节省内存资源
- 不可能降级
## 跳表
跳表节点（zskiplistNode）

```C
typedef struct zskiplistNode {
    sds ele;                    // 元素值（字符串，ZSet 的 member）
    double score;               // 分值（ZSet 的 score，用于排序）
    struct zskiplistNode *backward; // 后退指针（仅指向直接前驱，用于反向遍历）
    struct zskiplistLevel {
        struct zskiplistNode *forward; // 前进指针（每层一个）
        unsigned long span;            // 跨度：到下一个节点跨越的节点数（用于 rank 计算）
    } level[];                  // 柔性数组：层数动态分配（1 ~ ZSKIPLIST_MAXLEVEL=32）
} zskiplistNode;
```

- ele 是 SDS 字符串（Redis 字符串）
- score 是 double 类型（ZSet 按 score 排序，score 相同则按 ele 字典序）
- level[] 是柔性数组，每个节点层数随机（1~32），越高概率越低
- span 用于快速计算排名（rank）

```C
typedef struct zskiplist {
    struct zskiplistNode *header, *tail; // 头尾节点
    unsigned long length;                // 节点总数
    int level;                           // 当前最大层数（不包括头节点）
} zskiplist;
```
- header 是空头节点（不存数据，但有 32 层）
- tail 指向最后一个节点（方便 O(1) 获取最大元素）
### 跳表节点的查询过程
从头结点的最高层开始，逐一遍历每一层。遍历每一层节点，通过SDS类型元素和权重进行判断：
- 当前节点权重小于目标权重，跳表访问该层上的下一个节点
- 当前节点权重等于目标权重，但当前节点的SDS类型的数据小于目标数据，跳表访问该层上的下一个节点
- 如果两个条件都不满足或下一个节点为空时，跳到当前节点的下一层查找
### 跳表节点的层数设置
相邻两层的节点数量最理想的比例是2:1
如何维护？
创建跳表节点时，生成一个[0,1]的随机数，如果小于0.25，加一层，否则不加。最高64层，所以头节点初始化64层
### 为什么用跳表不用平衡树？
- 从内存占用上，跳表更灵活
- 在范围查询时，跳表操作更简单
- 算法实现难度上，跳表更简单。比如平衡树的插入删除
## quicklist
控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题
1. quicklist 节点（quicklistNode）

```C
typedef struct quicklistNode {
    struct quicklistNode *prev;   // 前驱节点
    struct quicklistNode *next;   // 后继节点
    unsigned char *zl;            // 指向 ziplist 的指针（实际存储数据）
    unsigned int sz;              // ziplist 占用的字节数
    unsigned int count : 16;      // ziplist 中元素个数（最多 65535）
    unsigned int encoding : 2;    // 编码方式：RAW=1, LZF=2（是否压缩）
    unsigned int container : 2;   // 容器类型：PLAIN=1（不用）, ZIPLIST=2
    unsigned int recompress : 1;  // 是否临时解压（用于迭代器）
    unsigned int attempted_compress : 1; // 尝试过压缩？
    unsigned int extra : 10;      // 预留位
} quicklistNode;
```
🔑 关键字段：
- zl：指向一个 ziplist（连续内存块）
- encoding：支持 LZF 压缩（节省内存）
- recompress：当使用迭代器访问时，临时解压，用完再压缩
2. quicklist 主体
```C
typedef struct quicklist {
    quicklistNode *head;          // 头节点
    quicklistNode *tail;          // 尾节点
    unsigned long count;          // 所有元素总数
    unsigned long len;            // 节点（ziplist 块）数量
    signed int fill : QL_FILL_BITS;       // 每个 ziplist 的最大容量（可正可负）
    unsigned int compress : QL_COMP_BITS; // LZF 压缩深度（0=不压缩）
    unsigned int bookmark_count: QL_BM_BITS; // 书签数量（用于快速跳转）
    quicklistBookmark bookmarks[];        // 书签数组（柔性数组）
} quicklist;
```
- 📌 fill 的含义（通过 list-max-ziplist-size 配置）：
- 正数：表示每个 ziplist 最多存多少 元素
- 负数：表示每个 ziplist 最大占用 字节数（-1=4KB, -2=8KB, ..., -5=64KB）
- 默认值：list-max-ziplist-size -2 → 每个 ziplist ≤ 8KB

- 📌 compress（通过 list-compress-depth 配置）：
- 表示 头尾各保留 N 个节点不压缩，中间节点压缩
- 例如 compress=1：只有 head 和 tail 不压缩，其余都压缩
- 默认值：0（不压缩），生产环境常设为 1 或 2
## listpack
只记录当前节点的长度，这样插入新元素，不会影响其他节点的字符长度变化
listpack 内存布局

```Text
+----------+----------+----------+----------+----------+
| total_bytes (4B) | num_elements (2B) | entry1 | entry2 | ... | END (1B=0xFF) |
+----------+----------+----------+----------+----------+
```
- total_bytes：整个 listpack 占用字节数（含头部和 END）
- num_elements：元素个数（最多 65535）
- END：固定为 0xFF，标识结束
entry 结构（变长）
每个 entry 格式如下：

```Text
+------------------+------------------+
| encoding & len   |      value       |
+------------------+------------------+
```