# 什么是缓存雪崩、击穿、穿透？
## 缓存雪崩
大量缓存数据在同一时间过期或者Redis故障宕机时，如果此时有大量用户请求，都无法在Redis中处理，全部请求同时访问数据库，导致数据库压力激增，严重的会导致数据库宕机，造成整个系统崩溃，这就是缓存雪崩。
- 大量数据同时过期；
- Redis宕机
### 大量数据同时过期
1. 均匀设置过期时间：给过期时间加随机数
2. 互斥锁：
   - 当业务线程处理用户请求时，如果访问的数据不在Redis中，就加一个互斥锁，保证同一时间只有一个请求来构建缓存（从数据库读取数据后将数据更新到Redis中），当缓存构建完成后，再释放锁。
   - 实现互斥锁最好设置过期时间，防止死锁发生
3. 后台更新缓存：
   - 让缓存永久有效，并将缓存更新的工作交给后台线程定时更新
   - 当内存紧张的时候，缓存数据会被淘汰，在被淘汰和后台更新这段时间里，业务线程读取缓存失败就返回空值
   - 有两种解决方式：
	   - 后台线程不仅定时负责更新缓存，也负责频繁地检测缓存是否有效
	   - 业务线程发现缓存失效之后，通过消息队列发送一条消息通知后台线程更新缓存，后台线程收到消息后，判断缓存是否存在，进行下一步操作。
业务刚上线的时候，把数据提前缓存起来，这就是缓存预热
### Redis故障宕机
对此有这样两种方式
- 服务熔断或请求限流机制：
	- 暂停业务应用对缓存服务的访问，直接返回错误
	- 只将少部分请求发送到数据库进行处理，再多的请求就在入口处直接拒绝服务
- 构建Redis缓存高可靠集群：主节点崩溃，切换从节点为主节点
## 缓存击穿
某个热点数据过期了，导致大量请求访问数据库，数据库被高并发请求冲垮
缓存击穿时缓存雪崩的子集，有两种方案解决：
- 互斥锁
- 不给热点数据设置过期时间，由后台异步更新缓存；或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间
## 缓存穿透
数据既不在缓存中，也不在数据库中，没办法构建缓存数据来服务后续的请求。当有大量这样的请求到来时，数据库的压力骤增

缓存穿透的发生有这两种情况：
- 业务误操作
- 黑客攻击

应对方案：
- 非法请求的限制
- 缓存空值或者默认值
- 使用布隆过滤器快速判断数据是否存在，避免通过查询缓存数据判断

#### 布隆过滤器如何工作

初始值都为0的位图数组 和 N个哈希函数 两部分组成

三个操作：
1. 使用N个哈希函数对数据作哈希计算，得到N个哈希值
2. 将N个哈希值对位图数组长度取模，得到每个哈希值在位图数组的对应位置
3. 将对应位置的值设置为1

新来的数据经过计算只要有一个对应位置不是1，就认为不存在

过滤器里有的不一定有，过滤器里没有的一定没有
# 数据库和缓存如何保证一致性？
## 先更新数据库还是先更新缓存？
不管怎样，在并发情况下都会导致数据不一致
## 先更新数据库还是先删除缓存？
更新数据时，不更新缓存，直接删除缓存中数据。后续督促数据时，请求来到数据库，读取数据后更新到缓存。此之谓Cache Aside ， 旁路缓存策略
- 写策略：
	- 更新数据库数据
	- 删除缓存中的数据
- 读策略：
	- 命中缓存，直接返回
	- 未命中，从数据库读数据，写入缓存，返回数据

### 先删除缓存
A要更新，先把缓存删了，此时B访问数据库，读到旧数据，更新缓存为旧数据。之后A更新数据，导致缓存和数据库数据不一致

延时双删可以大概解决
### 先更新数据库
假设某个用户数据不存在，请求A从数据库读到老数据，为写入缓存B更新数据，清空缓存，之后A将老数据写入缓存，缓存和数据库仍然数据不一致

此种情况极难出现，因为写入缓存极快，不可能中间有数据库更新插进来

解决方案：
- 更新缓存前加一个分布式锁
- 给更新后的缓存加一个过期时间，防止删除操作失败，访问到旧数据

保证写策略的第二个操作一定成功（删除缓存）的方案：
- 消息队列重试机制：
	- 将第二步操作的数据加入到消息队列，由消费者来处理。对代码的侵入性强，需要改造业务代码
- 订阅MySQL binlog + 消息队列 + 重试缓存的删除，规避了代码入侵的问题，缺点就是引入的组件多

两种方式都是异步操作缓存