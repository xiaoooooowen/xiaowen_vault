# AOF持久化怎样实现？
## AOF日志
Redis每执行一条指令，都会把该命令以追加的方式写入到一个文件里
```AOF
*3
$3
SET
$5
hello
$5
world
```
优点：
- 避免额外的检查开销
- 不会阻塞当前写操作命令的执行

缺点：
- 如果写日志的操作没完成，服务器宕机了，数据就会有丢失的风险
- 可能会阻塞下一个命令
## 三种写回策略
AOF日志记录过程：
1. Redis执行完命令后，会将命令追加到sever.aof_buf缓冲区
2. 通过write()系统调用，将缓冲区的数据写入到AOF文件，此时数据只是拷贝到了内核缓冲区pagecache，等待内核将数据写入磁盘
3. 内核决定内核缓冲区什么时候写入硬盘
在redis.conf文件中用appendfsync配置控制上面三个步骤
- Always：每次命令执行fsync()
- Everysec：每秒
- No：由操作系统决定
## AOF重写机制
为了避免AOF文件越写越大，提供了AOF重写机制
AOF重写机制在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到新的AOF文件，等到记录全部记录完后，就将新的AOF文件替换掉现有的AOF文件
（合并历史记录）
## AOF后台重写
当AOF文件大于64MB，就会对AOF文件进行重写。但是重写过程很耗时，所以重写线程不能放在主进程中。
Redis重写AOF过程是由后台子进程bgrewriteaof来完成，有两个好处：
- 子进程进行AOF重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程
- 子进程带有主进程的数据副本，不用加锁来保证数据安全。
### 子进程是怎么拥有主进程一样的数据副本呢？
fork系统调用生成子进程时，操作系统会把主进程的页表复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存。
当父进程或子进程在向内存发起写操作时，CPU就会触发==写保护中断==，然后操作系统会在【写保护中断处理函数】里进行物理内存的复制，并重新设置其内存映射关系，将父子进程的内存读写权限设置为可读写，最后才会对内存进行写操作，这个过程被称为【写时复制】。

有两个阶段会导致阻塞父进程：
- 创建子进程过程中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞时间越长；
- 创建完子进程后，如果子进程或父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞时间也越长。
### 重写AOF日志过程中，如果主进程修改了已经存在的Key-Value，此时这个Key-Value数据在子进程中的内存数据和父进程的内存数据不一致，怎样解决？
设置一个AOF重写缓冲区，这个缓冲区在创建bgrewrited子进程后开始使用

在重写AOF日志的过程中，当Redis执行完一个写命令后，他会同时将这个写命令写入到AOF缓冲区和AOF重缓冲区

在bgrewriteaof子进程执行AOF重写期间，主进程需要执行以下三个工作：
- 执行客户端发来的命令；
- 将写命令追加到【AOF缓冲区】;
- 将写命令追加到【AOF重写缓冲区】
当子进程完成重写工作后，会向主进程发送一条信号.
主进程收到该信号后，会调用一个信号处理函数：
- 将AOF重写缓冲区中的所有内容追加到新的AOF文件中
- 新的AOF文件进行改名，覆盖现有的AOF文件

整个过程中，写时复制 和 信号函数处理函数会对主进程造成阻塞。



# RDB快照如何实现？

RDB记录某一个瞬间的内存数据，记录的是实际数据
## 快照怎么用
- save命令：主线程生成RDB文件，会阻塞主线程；
- bgsave命令：创建子进程来生成RDB文件，避免主线程阻塞
```confg
save 900 1 //900秒之内，进行至少1次修改
save 300 10
save 60 10000
```
Redis快照是全量快照，是一个比较重的操作，频率太频繁，会对Redis性能造成影响
## 执行快照时，数据能被修改吗？

能，依旧根据写时复制技术
但没办法在RDB快照中保存最新的数据，如果此时崩溃，不会保存下写时复制时的数据

遇到极端情况下，写时复制会导致所有共享内存被修改，此时内存占用是原先的两倍

## RDB 和 AOF 合体，混合持久化

AOF重写日志时，重写子进程先将与主线程共享的内存数据以RDB的方式写入到AOF文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以AOF的方式写入到AOF文件，写入完成后通知主进程将新的含有RDB格式和AOF格式的文件替换旧的AOF文件
这样重启加载也会更快
# Redis大Key对持久化有什么影响？
## 大Key对AOF日志的影响
使用Always策略持久化大Key，因为写入的数据量很大，主线程在执行fsync()时，阻塞时间会比较久
## 大Key对AOF重写和RDB的影响
当AOF日志写入了很多大Key，AOF的日志文件会很大，很快就会触发AOF重写

AOF重写和RDB都会调用fork()函数，将父进程的页表复制一份给子进程，如果页表很大，复制过程会很耗时，执行fork()函数就会阻塞。
如果fork耗时超过一秒，就需要做出优化调整：
- 单个实例的内存占用控制在10GB以下
- 如果把redis当作缓存使用，不关心数据安全问题，可以关闭AOF和AOF重写
- 主从架构中，要适当调大repl-black-size,避免因为repl_backlog_buffer不够大，导致主节点频繁采用全量同步的方式。因为全量同步会创建RDB文件，也就是会调用fork函数

写时复制也会导致父进程阻塞。父进程对共享的大Key进行了修改，内核会发生写时复制，在复制物理内存的过程中，就会导致父进程阻塞

>Linux开启内存大页会导致Redis性能变慢

## 大Key的其他影响
1. 客户端超时阻塞
2. 网络阻塞
3. 阻塞工作线程
4. 内存分布不均

如何避免大Key？
- 设计阶段将大Key拆分成小Key
- 检查是否存在大Key，如果有用unlink命令删除，它是异步的，不会阻塞主线程















