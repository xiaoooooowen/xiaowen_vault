# Redis过期删除策略和内存淘汰策略有什么区别？
## 过期删除策略
Redis可以对Key设置过期时间，过期删除策略完成这个工作
### 如何设置过期时间？
- `expire <key> <n>`
- `pexpire <key> <n>`
- `expireat <key> <n>`
- `pexpireat <key> <n>` 
### 如何判定Key已经过期了？
```C
typedef struct redisDb {
    dict *dict;                 /* 主键空间：key -> value */
    dict *expires;              /* 过期字典：key -> expire time (毫秒) */
    // ... 其他字段（如 blocking_keys, watched_keys 等）
} redisDb;
```
所有设置了过期时间的Key都会保存在过期字典里
当我们查找一个Key时，首先会在过期字典里查找并判断
### 过期删除的策略有哪些？
- 定时删除：
	- 在设置Key的过期时间时，同时创建一个定时条件，当时间到达时，由事件处理器自动执行Key的删除操作
	- 优点：内存友好
	- 缺点：同时大量Key过期，影响服务器的响应时间和吞吐量，CPU不友好
- 惰性删除：
	- 不主动删除，访问的时候检测一次是否过期，如果过期删除
	- 优点：CPU友好
	- 缺点：内存不友好
- 定期删除：
	- 每隔一段时间随机从数据库中取出一定数量的Key进行检查，并删除其中过期的Key
	- 优点：减少了CPU资源占用，减少了内存占用
	- 缺点两方面都不如上面两种
	- 难以确定删除操作执行的时长和频率
### Redis的过期删除策略是什么？

Redis选择【惰性删除 + 定期删除】这两种策略搭配使用
- 惰性删除：访问或修改key之前，调用expireIfNeeded函数对其检查：
	- 如果过期，则删除Key，可以根据参数选择异步或同步删除
	- 没有过期返回数据
- 定期删除：
	- 默认每秒十次
	- 随机选择20个Key，如果已过期比例超过25%,循环。否则停止
## 内存淘汰策略
当Redis的运行内存已超过Redis设置的最大内存之后，就会使用内存淘汰策略删除符合条件的Key，保障Redis的高效运行
### 如何设置Redis的最大运行内存？
`maxmemory<bytes>`设定
不同操作系统不一样
### Redis内存淘汰策略有哪些？
1. 不进行淘汰
2. 进行数据淘汰：
	1. 对过期数据淘汰
		1. volatile-random
		2. volatile-ttl
		3. volatile-lru
		4. volatile-lfu
	2. 对所有数据淘汰
		1. allkeys-random
		2. allkeys-lru
		3. allkeys-lfu

redis如何实现LRU算法？
- 加一个字段记录数据的最后一次访问时间，会有缓存污染

redis如何实现LFU算法？
增加记录访问频次这个字段
同一个lru字段，使用方式不同，在LFU中
- 高16位记录时间戳
- 低8位`LOG_C`记录访问频次，访问一次，会根据上次访问时间衰减一次，然后按照一概率增加logv
