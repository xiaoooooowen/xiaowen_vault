## 常见面试题
### 索引的分类
1. 按照数据结构：
	1. B+树索引
	2. Hash索引
	3. Full-Text索引
2. 按照物理存储：
	1. 聚簇索引（叶子节点储存数据）
	2. 二级索引（叶子节点储存主键值）
3. 按照字段特性：
	1. 主键索引
	2. 唯一索引
	3. 普通索引
	4. 前缀索引
4. 按照字段个数：
	1. 单个索引
	2. 联合索引：非叶子节点存储两个字段的值作为Key，遵循最左匹配原则
### 什么时候创建索引？
- 字段有唯一性限制的
- 经常用where查询字段的， 创建联合索引可以避免回表的
- 某个字段要用到order_by的，因为在B+树中索引是排好序的
所应有什么缺点：
- 占内存
- 创建和维护需要耗费时间，
- 降低表增删改的效率，索引越多，增删改时要对索引动态维护
什么情况不需要索引：
- 数据量不大的时候
- 经常被修改的字段
- 字段内容区分度低的
- 不需要where、order_by的字段，浪费
### 有什么索引优化的方法
- 前缀索引优化：字符串的前几个字符建立索引
- 覆盖索引优化：联合索引，索引包含需要query的几个字段，在InnoDB一次查找比较，不需要回表
- 主键ID最好是自增的:避免页分裂
- 索引最好设置为NOT NULL的：
	- NULL占内存
	- 会导致某些索引失效
### 如何防止索引失效
1. 联合索引遵循最左匹配原则
2. 前缀索引遵循最左匹配原则
3. where 中加 or 条件是，最好前后两个字段都建立索引
4. 查询时不对索引建立字段做函数，隐式类型转换，计算操作
## 为什么MySQL使用B+树作为索引的数据结构
从增删改查性能四个方面来说：
1. 增：增加叶子节点索引重建过程简单，因为有冗余节点
2. 删：只需要删除叶子节点，索引重建过程简单
3. 改：只需要修改叶子节点
4. 查：
	1. 支持快速的等值查询和范围查询，基于叶子节点采用双向链表连接
	2. 层数较低，时间复杂度低，避免进行多次I/O操作

从数据结构本身来说：
1. 不会退化成链表
2. 占用内存少，非叶子节点只存储索引
> MySQL 选择 B+ 树 作为索引的底层数据结构，主要是因为它在磁盘 I/O 效率、查询性能稳定性、范围查询支持等方面具有显著优势。我们可以从 增、删、改、查 四个操作以及 数据结构本身特性 两个角度来理解：
> 
> 一、从 DML 操作（增删改查）性能来看：
> 插入（Insert）
> 
> B+ 树通过页分裂机制在叶子节点插入新记录。由于非叶子节点只存储索引键和指针，不存实际数据，分裂时只需调整少量指针，无需重建整个索引，维护成本低。
> 
> 删除（Delete）
> 
> 删除操作仅作用于叶子节点。当节点数据量过少时，B+ 树会通过兄弟节点合并或借位来维持平衡，整个过程是局部调整，不会引发全局重构。
> 
> 更新（Update）
>
> 如果更新的是非索引字段，只需修改叶子节点中的数据；如果更新的是索引字段，则需先删除旧键值再插入新键值。得益于 B+ 树的稳定结构，这类操作依然高效。
> 
> 查询（Select）
> 
> 等值查询：从根节点逐层向下查找，时间复杂度为 O(logₙN)，其中 n 是每页可存储的键值数量（通常几百到几千），树高一般只有 2~4 层，I/O 次数极少。
> 范围查询：所有叶子节点通过双向链表顺序连接，一旦定位到起始位置，即可高效遍历后续数据，无需回溯树结构。
> 
> 二、从数据结构本身的特性来看：
> 高度平衡，永不退化
> B+ 树是多路平衡搜索树，无论数据如何插入，都能保证所有叶子节点在同一层，最坏情况下的查询复杂度仍是 O(log N)，不会像二叉树那样退化成链表。
> 
> 空间利用率高，I/O 友好
> 非叶子节点只存储索引键和子节点指针，不存实际数据，因此单个页能容纳更多索引项，进一步降低树高。
> 节点大小通常与 InnoDB 的页大小一致（默认 16KB），契合磁盘预读和缓存机制，极大减少磁盘 I/O。
> 
> 天然支持聚簇索引与二级索引
> 在 InnoDB 中，主键索引（聚簇索引）的叶子节点存储完整行数据；
> 二级索引的叶子节点存储主键值，通过主键回表获取数据。
> 这种设计让 B+ 树既能高效支持主键查询，也能灵活构建多列索引。
> 💡 总结：
> B+ 树在减少磁盘 I/O、支持高效范围扫描、保持结构稳定等方面完美契合数据库对索引的核心需求，因此成为 MySQL（尤其是 InnoDB 引擎）的首选索引结构。


