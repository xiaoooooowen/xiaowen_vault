## MySQL中有哪几种锁？
MySQL中根据加锁的范围，可以分为全局锁、表级锁、行级锁
#### 全局锁：

```MySQL
	flush tables with read lock
```
执行这条命令锁住整张表，只能对表进行读操作，释放锁需要执行下面这条命令
```MySQL
	unlock tables
```
当会话结束，锁也会自动释放
他主要用于全库的逻辑备份
#### 表级锁
##### 表锁：
是数据库的一种粗颗粒度的锁，他一般用于对数据库进行DDL操作，一般不适用于高并发的场景
- 控制效果：
	- 表写锁（共享锁）：只允许一个线程访问表数据
	- 读锁（排它锁）：允许多个线程同时读锁，不允许进行写操作，会阻塞所有写操作
- 优缺点：
	- 实现简单，开销小，在备份、DDL操作等场景下适用
	- 锁粒度太粗，容易导致大量线程阻塞，不适用于高并发场景
因此，MySQL选择了InnoDB作为引擎，他支持更细锁粒度的行锁
##### 元数据锁（Meta Date Lock）：
元数据锁是MySQL Sever 层自动管理的一种表级锁，他保护数据的元数据，确保在事务执行期间表结构不会被并发修改
- 当执行DML操作时，加MDL读锁
- 当执行DDL操作时，加MDL写锁
MDL生命周期和事务一致，事务开启时获得，事务提交或回滚释放。
如果一个事务执行了select，但并没有提交，他会一直持有MDL读锁。此时如果有DDL请求写锁，DDL会被阻塞；又因为写锁获取优先级高于其他锁，对该表的新查询也会因为排队等待而被阻塞，从而造成链接堆积，服务雪崩
##### AUTO_INC锁
MySQL InnoDB通过 `InnoDB_autoinc_lock_mode`来控制自增锁的模式，用来在并发性能和自增值连续性上做权衡：
- 模式0：传统模式。在执行插入操作时自动获取锁，获取锁后为自增值赋值，等插入操作完成后释放锁。
	- 可以极大的保障数值连续性，但在并发场景下，由于锁的存在，其他事务无法进行插入操作，性能较差
- 模式1：默认模式。对简单插入在赋值递增值之后释放锁，对批量插入，依旧获得全表锁，保证递增值的连续性
	- 配合ROW格式的binlog可以避免主从不一致的问题
- 模式二：交错模式。对所有插入都不使用表级锁，自增值分配完全并发
	- 在使用STATEMENT格式的binlog会发生主从不一致的问题
因此，默认情况下，都使用模式一
##### 意向锁
意向锁（Intention Locks）是 InnoDB 引入的一种**表级元锁**，本身不锁定任何数据行，而是用来**表明事务打算在表中的某些行上加何种类型的行级锁**。它的核心目的是：**在需要加表级锁时，避免全表扫描来检查行锁状态，从而提升并发效率**。
意向锁分为两种：
- **IS（Intention Shared）锁**：表示事务打算对某些行加 **S 锁（共享行锁）**；
- **IX（Intention Exclusive）锁**：表示事务打算对某些行加 **X 锁（排他行锁）**。
**关键特性：**
1. **意向锁之间完全兼容**：IS 与 IS、IS 与 IX、IX 与 IX 都可以同时存在；
2. **意向锁与行级锁共存**：加了 IX 锁的表，其他事务仍可正常读写未被锁定的行；
3. **意向锁只与表级 S/X 锁冲突**：
    - 表级 S 锁 与 IX 不兼容；
    - 表级 X 锁 与 IS、IX 都不兼容；
4. **自动管理**：当事务对某行加 S/X 锁时，InnoDB 会自动在表上加对应的 IS/IX 锁，无需用户干预。
#### 行级锁
InnoDB 的行级锁机制包含四种类型，共同实现高并发下的数据一致性：
##### 记录锁（Record Lock）
锁定单条索引记录，分为共享锁（S）和排他锁（X），用于保证对已有行的读写一致性。
##### 间隙锁（Gap Lock）

锁定索引记录之间的“间隙”（如 (10, 20)），防止其他事务在此区间插入新记录，从而避免幻读。

多个事务可以同时持有相同间隙的间隙锁，彼此不冲突。
##### 临键锁（Next-Key Lock）

是记录锁与间隙锁的组合，锁定一个左开右闭区间（如 (10, 20]），既保护已有记录，也封锁其左侧间隙。

这是 InnoDB 在可重复读（RR）隔离级别下防止幻读的核心机制。
##### 插入意向锁（Insert Intention Lock）

是一种特殊的间隙锁，表示事务打算在某个间隙中插入新记录。
它与其他插入意向锁兼容，因此允许多个事务在同一个间隙的不同位置并发插入，但会被间隙锁或临键锁阻塞。
##### 总结
这些锁机制协同工作，在保证 ACID 一致性的前提下，最大化并发性能。值得注意的是，在读已提交（RC）隔离级别下，间隙锁和临键锁会被禁用，仅保留记录锁，以换取更高并发，但可能产生幻读。
## MySQL是怎样加锁的？
### 什么SQL语句会加行级锁？
普通的select不会加锁，他的一致性通过MVCC实现，两种加锁的特殊的select会加锁，update和delete都会加互斥锁
### MySQL是怎么加行级锁的？
加锁的对象是索引，基本单位是临键锁，在不同场景下，临键锁会退化成不同的锁，因为在某些场景下，退化后的锁已经可以解决幻读问题
#### 唯一索引等值查询
- 当查询的记录存在时，临键锁退化成记录锁（已经存在了，别给我删了）
- 当查询记录不存在时，临键锁退化成间歇锁（已经不存在，别再插入了）
#### 唯一索引范围查询
利用间歇锁和记录锁搭配，把范围查询的区域锁定住，不进行任何修改
1. 大于 > a :
	 (a,last] 临键锁 ，(last，supremum)间歇锁
2. 大于等于 >= a :
	 a 加 记录锁 ，(a,last] 临键锁 ，(last，supermum) 间歇锁
 3. 小于 < a :
	 - 如果存在：(infimum,a) 间歇锁 ，
	 - 如果不存在：(infimum,exit_min] 临键锁 , (infimum,supremum) 间歇锁
 4. 小于等于 <= a ;
	 - 如果存在：(infimum,exit_min] 临键锁 , (exit_min,a] 临键锁
	 - 如果不存在：(infimum,exit_min] 临键锁 , (infimum,supremum) 间歇锁

> **在唯一索引上执行范围查询时，InnoDB 会对扫描到的每一条记录加 Next-Key Lock，并在范围两端加 Gap Lock（指向 infimum/supremum）。**
> 
> **关键规则：**
> 
> 1. **范围查询（>、<、>=、<=）不会退化**，即使条件值存在；
> 2. **退化只发生在唯一索引的等值查询（=）**，此时 Next-Key Lock 退化为 Record Lock；
> 3. **Supremum 和 Infimum 是虚拟记录**：
>     - 锁 (x, supremum) → **Gap Lock**
>     - 锁 (infimum, x) → **Gap Lock**
> 4. **实际加锁范围 = 索引扫描路径覆盖的所有记录 + 两端间隙**
   
#### 非唯一索引等值查询
当我们用非唯一索引进行等值查询的时候，因为存在两个索引，一个是主键索引，一个是非唯一索引（二级索引），所以在加锁时，同时会对这两个索引都加锁，但是对主键索引加锁的时候，只有满足查询条件的记录才会对它们的主键索引加锁。

针对非唯一索引等值查询时，查询的记录存不存在，加锁的规则也会不同：
- 当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁。
  ==这里再二级索引加临键锁是为了防止幻读，比如年龄也是22，但主键id不一样，就会成功插入
- 当查询的记录「不存在」时，扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁。

#### 非唯一索引范围查询
主键索引和非唯一索引全部都是临键锁
#### 无索引查询
相当于全表扫描，对每一个索引加临键锁
update和delete不加索引检索，退化导致整个表被锁，其他事务都被阻塞
## 什么情况下会引发死锁？
**死锁的定义：** 两个事务或多个事务互相等待锁，导致所有的事务都处于阻塞状态
**四个核心条件**：
1. 互斥条件：资源只能被一个事务占有，不能多个事务共享
2. 请求与保持条件：事务在持有锁的同时尝试获取新的锁
3. 不剥夺条件：事务持有的锁只能自己释放，不能被剥夺
4. 循环条件：多个事物之间形成等待环路

发生死锁的场景：
1. 不同顺序的写操作：多个事务以不同顺序更新相同的资源，形成循环等待
2. 间歇锁冲突：在可重复读隔离级别下，范围查询的间歇锁可能会相互阻塞
	```MySQL
	start A :
	select * in order where id > 100 for update;
	insert id = 110 into order
	end
	
	start B :
	select * in order where id > 110 for update;
	insert id = 112 into order
	```
3. 唯一键冲突：并发插入相同唯一键值导致死锁
4. 混合锁类型：表锁与行锁、读写锁混合使用导致死锁
###   如何避免死锁？
#### 1.监控保障
1. 设置事务锁的超时等待时间
2. 开启主动死锁检测
#### 2.统一访问顺序
#### 3.优化事务设计
#### 4.合理使用索引
### 实例
```mySQL
-- 创建表和数据
CREATE TABLE students (
    id INT PRIMARY KEY,
    no VARCHAR(10),
    name VARCHAR(50),
    age INT,
    score INT
);

INSERT INTO students (id, no, name, age, score) VALUES
(15, 'S0001', 'Bob', 25, 34),
(18, 'S0002', 'Alice', 24, 77),
(20, 'S0003', 'Jim', 24, 5),
(30, 'S0004', 'Eric', 23, 91),
(37, 'S0005', 'Tom', 22, 22),
(49, 'S0006', 'Tom', 25, 83),
(50, 'S0007', 'Rose', 23, 89);

-- 事务A执行
BEGIN;
-- time1: update students set score=100 where id=25
UPDATE students SET score=100 WHERE id=25;
-- time3: insert into students(id, no, name, age, score) value(25, 's0025', 'sony', 28,90)
INSERT INTO students(id, no, name, age, score) VALUES(25, 's0025', 'sony', 28, 90);
COMMIT;

-- 事务B执行  
BEGIN;
-- time2: update students set score=100 where id=26
UPDATE students SET score=100 WHERE id=26;
-- time4: insert into students(id, no, name, age, score) value(26, 's0026', 'ace', 28,90)
INSERT INTO students(id, no, name, age, score) VALUES(26, 's0026', 'ace', 28, 90);
COMMIT;
```
==因为update和select for update 都回加临键锁，有些情况会变成间歇锁，但间歇锁和插入意向锁互斥，l两个事务的插入意向锁互相等待对方释放间歇锁，就导致死锁

