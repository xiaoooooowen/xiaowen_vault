### 了解MySQL的事务吗？
MySQL事务时保证一组数据库操作要么全部成功，要么全部失败回滚，保证数据的完整性和一致性。InnoDB引擎通过ACID四大特性来实现事务：
- 原子性：通过undo log实现，在事务中途失败时用于事务回滚
- 一致性：是事务的最终目标，由其他三个特性共同保证
- 隔离性：多个事务并发执行时，彼此互不干扰。InnoDB通过锁和多版本并发控制MVCC实现，有四种隔离级别
	- 读未提交l
	- 读已提交
	- 可重复读
	- 串行化
- 持久性：事务一旦提交，其结果就永远保存在数据库中，即使数据库崩溃也不丢失。InnoDB通过redo log实现，采用WAL机制，先写日志在写数据页，崩溃后通过日志回复未刷盘的数据。
综上所述，MySQL事务通过锁、日志、MVCC协同工作，确保了高并发下数据的安全性和一致性。
### 事务有哪些特性？（思考怎么结合自己的项目）
1. 原子性：一个事务中的操作，要么全部成功，要么全部失败，不会结束在某个中间环节。如果事务执行过程中发生异常，会被回滚到开始之前的状态
2. 一致性：事务操作完成前后，数据满足完整性约束，数据库保持一致性状态（追问：什么原因会导致一致性问题）
3. 隔离性：并发的几个事务，互不干扰。就是数据库允许多个并发事务同时对其数据进行读写操作的能力。
4. 持久性：事务处理结束后，对数据的修改就是永久的，即使系统故障也不会丢失
#### InnoDB引擎通过什么技术来实现这四个特性？
- 原子性通过undo_log回滚事务来保证；
- 持久性通过redo_log重做事务来保证；
- 隔离性通过MVCC多版本并发控制或锁机制来保证；
- 一致性通过原子性、持久性、隔离性来保证
#### MySQL每条语句都使用事务吗？
技术上，MySQL的每条DML语句都在一个独立的事务中执行并自动提交。
业务上，我们通常说的使用事务是显式事务，把多个DML语句包装在一起保证原子性。另外，DDL语句会隐式提交当前事务，且无法回滚。
#### 自动提交的性能影响？
自动提交模式下，每个语句都要写redo_log、等待磁盘同步，在高并发场景下会有性能开销，因此我们选择批量操作，先`SET autoCommite = 0`，执行完批量操作后再显式`COMMIT`,能显著提升性能
### 并行事务会出现哪些问题？
1. 脏读：指读到其他事物尚未提交的数据。线程A访问到线程B未提交的数据，如果此时线程B发生错误进行回滚，就会导致脏读
2. 不可重复读：指在同一个事务中，多次读取同一行数据访问到的数据不一致。线程A前后两次访问同一个数据发现不一致，因为在两次访问数据之间有其他线程修改了数据并提交
3. 幻读：指在同一个事务中，多次执行同一个条件的查询，返回的记录行数不一致。线程A第一次查询某个记录行数为x，但第二次统计记录行数为y，前后两次行数不一致，原因是有其他线程在中间执行了插入或删除操作
MySQL通过不同的隔离级别解决这些问题
### 事务的隔离级别有哪些？
1. 读未提交：事务可以访问其他事务未提交的数据，无法避免任何问题
2. 读已提交：事务只能访问其他事务已经提交的数据，可以避免脏读问题
3. 可重复读：事务可以重复读当前访问的数据，并且保证重复读的数据和事务开启时的数据一致。可以避免不可重复读问题。这也是InnoDB引擎默认的隔离级别，而且InnoDB引擎通过MVCC和间歇锁可以解决幻读问题（==分别针对快照读和当前读==）
4. 串行化：当一个事务对某一行数据进行访问时，其他事务的访问请求都会被阻塞，因此可以避免所有并发问题，但高并发场景下性能较差
#### 这些隔离级别分别是如何实现的？
- 读未提交：直接访问最新的数据
- 串行化：通过加读写锁来避免并发访问
- 读已提交和可重复读：通过Read View来实现，区别在于二者创建Read View的时机不同，读已提交在**每个语句执行前**都会重新生成一个Read View ，可重复读是在 **启动事务时**创建一个Read View，整个执行过程中使用一个Read View
### Read View 在 MVCC 中是如何实现的？
他通过RV的四个字段和索引记录中的两个隐藏列实现
- RV有四个字段：
	- min_ids:创建RV时活跃且未提交的事务中最小事务的id
	- max_ids:创建RV时应该给下一个事务分配的id值
	- creator_trx_id:创建该RV的事务的事务id
	- m_ids: 创建RV时，当前数据库中活跃且未提交的事务id列表
- 聚簇索引记录中有两个隐藏列：
	- trx_id:表示事务的id，当一个事务对某条聚簇索引记录进行修改时，就会把自己的trx_id放入其中
	- roll_pointer:每次对某条聚簇索引记录进行修改时，就会把旧版本的记录写入到undo日志中，这个隐藏列是一个指针，指向每一个旧版本记录，可以通过它找到修改前的记录。
创建RV后，我们就可以把trax_id通过其中的三个字段划分为三种情况：

> ==已提交事务== <min_trx_id> ==已启动但未提交的事务== & ==已经启动已经提交== <max_trx_id> ==还没有开启的事务==

一个事务去访问记录的时候，除了自己的记录总是可见，还会遇到以下几种情况：
1. 如果记录的trx_id < min_ids ,说明这个版本的记录是在创建RV前已经提交的事务生成的，所以该版本的记录岁当前事务可见
2. 如果记录的trx_id > max_ids ,说明这个版本的记录是在创建RV后才启动的事务生成的，所以该版本的记录对当前事务不可见
3. 如果在min和max之间，还要判断是否在m_ids上：
	1. 如果在m_ids上，说明生成该版本记录的事务任然活跃着，没有提交，所以该版本的记录对当前事务不可见
	2. 如果不在m_ids上，说明生成该版本记录的事务已经提交，该版本的记录对当前事务可见
通过版本链来控制并发事务访问同一个记录就叫做MVCC

### 可重复读是如何工作的？
假设事务A的creator_id是51，事务A启动后，事务B也启动，creator_id为52，此时他们各自有一个Read View 
```C
trxA{
	creator_trx_id = 51 ;
	m_ids = [51] ;
	min_id = 51 ;
	max_id = 52 ;
}
trxB{
	creator_trx_id = 52 ;
	m_ids = [51 , 52] ;
	min_id = 51 ;
	max_id = 53 ;
}
```

1. 假设此时事务A、B同时访问行student 小文 ，查询到相同数据小文成绩为90 ，小文的trx_id为50 。
2. 此时A修改小文的成绩为100，但并没有提交事务，此时小文的trx_id变为51，roll_pointer 指向上一条 trx_id为50的记录。
3. 此时B再次访问小文，观察到此时trx_id为51，在自己的m_ids上，说明此时这条创建这条记录的事务还未提交，B不能访问，于是根据roll_pointer访问上一条记录，发现trx_id为50，小于自己的min_id,可以访问，再次读到成绩为90。
4. 此时A提交事务
5. B再次读取数据，B 在 RR 隔离级别下复用首次 SELECT 时创建的 ReadView，不会因其他事务提交而更新。所以即使A提交了事务，B依旧查询到成绩为90的记录。
### 读提交是如何工作的？
假设事务A的creator_id是51，事务A启动后，事务B也启动，creator_id为52，此时他们各自有一个Read View 
```C
trxA{
	creator_trx_id = 51 ;
	m_ids = [51] ;
	min_id = 51 ;
	max_id = 52 ;
}
trxB{
	creator_trx_id = 52 ;
	m_ids = [51 , 52] ;
	min_id = 51 ;
	max_id = 53 ;
}
```

1. 假设此时事务A、B同时访问行student 小文 ，查询到相同数据小文成绩为90 ，小文的trx_id为50 。
2. 此时A修改小文的成绩为100，但并没有提交事务，此时小文的trx_id变为51，roll_pointer 指向上一条 trx_id为50的记录。
3. 此时B再次访问小文，观察到此时trx_id为51，在自己的m_ids上，说明此时这条创建这条记录的事务还未提交，B不能访问，于是根据roll_pointer访问上一条记录，发现trx_id为50，小于自己的min_id,可以访问，再次读到成绩为90。
4. 此时A提交事务
5. B再次读取数据，B 在 RC 隔离级别下创建新的的 ReadView,此时再次访问记录，trx_id = 51 ，小于min_id ,证明是在创建这条Read View前已经提交的事务，可以读取数据，查询到成绩为100
	```C
	trxB{
		creator_trx_id = 52 ;
		m_ids = [52] ;
		min_id = 52 ;
		max_id = 53 ;
	}
	```

### 当前读怎么解决幻读？
MySQL 通过 Next-Key Locking 机制 来解决当前读下的幻读问题。
Next-Key Lock 是 记录锁（Record Lock）和间隙锁（Gap Lock）的组合，它不仅锁住符合条件的现有记录，还锁住前一个索引记录到当前记录之间的间隙，形成一个左开右闭区间，从而防止其他事务在该范围内插入新记录。
具体来说：
- 对于唯一索引上的等值查询（且记录存在），InnoDB 通常只加记录锁，不加间隙锁；
- 对于普通索引或范围查询，InnoDB 会使用 Next-Key Lock，覆盖整个查询范围；
- 如果查询条件匹配不到任何记录，也会对相应间隙加锁，防止插入。
这种机制确保在事务执行期间，满足查询条件的数据集合不会因其他事务的插入而发生变化。

最佳实践是：在事务中若需保证范围操作的一致性，应尽早使用 SELECT ... FOR UPDATE 显式加锁，并避免混合使用快照读与当前读，从而彻底规避幻读风险。

- 注意：Next-Key Lock 依赖索引，若查询条件无索引，InnoDB 可能退化为全表扫描并加表级锁，严重影响并发性能。
### 幻读被被完全解决了吗？
#### 场景一 混合读写场景
仅使用快照读（普通 SELECT），但后续用当前读更新数据
```sql
-- 事务 A（RR 隔离级别）
BEGIN;
SELECT COUNT(*) FROM t WHERE id > 10;  -- 快照读，返回 0

-- 此时事务 B 插入并提交：
-- INSERT INTO t (id) VALUES (15); COMMIT;

-- 事务 A 继续：
UPDATE t SET name = 'x' WHERE id > 10;  -- 当前读！会读到 id=15 的新行
COMMIT;
```
问题：
第一次 SELECT 看不到 id=15；
但 UPDATE 是当前读，会看到并修改这条新插入的行；
从逻辑上讲，事务 A “凭空”更新了一条它之前“看不见”的记录，违反了可重复读的一致性预期

如果业务要求强一致性，范围操作应该统一使用当前读
```sql
SELECT * FROM t WHERE id > 10 FOR UPDATE;  -- 先加锁
UPDATE t SET name = 'x' WHERE id > 10;
```
**关键点**：
- 第一次是快照读（普通SELECT），基于Read View
- 第二次是当前读（SELECT ... FOR UPDATE），读取最新数据
- 在两次查询之间，其他事务插入了满足条件的新记录
#### 场景二 先查后更新场景
```sql
-- 会话A
START TRANSACTION;
-- T1：统计年龄>20的人数
SELECT COUNT(*) FROM users WHERE age > 20; -- 返回2

-- 会话B插入新用户
INSERT INTO users (id, name, age) VALUES (4, 'David', 22);
COMMIT;

-- T2：会话A更新所有年龄>20的用户
UPDATE users SET status = 'active' WHERE age > 20;
-- 此时会更新3条记录！包括会话B插入的那条

-- T3：再次统计
SELECT COUNT(*) FROM users WHERE age > 20; -- 返回3 ← 幻读！
```

**关键点**：
- UPDATE语句是当前读，会看到其他事务已提交的插入
- 导致事务内数据出现不一致
#### 为什么可重复读不能完全避免幻读？
##### MVCC的局限性
```python
# MVCC解决的是快照读的幻读
def snapshot_read():
    # 基于事务开始时的Read View
    # 不会看到其他事务的插入 → 无幻读
    pass

def current_read():
    # 读取最新提交的数据
    # 会看到其他事务的插入 → 可能幻读
    pass
    ```
    
##### 锁机制的边界
- 行锁：只锁住现有的行
- 间隙锁：锁住记录之间的间隙，防止插入
- Next-Key锁：行锁+间隙锁
但是：如果事务中混合使用不加锁的查询和加锁的查询，间隙锁的保护就会失效。
#### 解决方案
##### 方案一：统一使用当前读
```sql
START TRANSACTION;
-- 事务开始后立即用当前读锁定范围
SELECT * FROM users WHERE age > 20 FOR UPDATE;  -- 加Next-Key锁

-- 其他事务的插入会被阻塞
-- 后续所有操作都基于这个锁定视图

-- 执行业务逻辑...
UPDATE users SET status = 'active' WHERE age > 20;

COMMIT;
```

##### 方案二：提升隔离级别
```sql
-- 使用串行化隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;

SELECT * FROM users WHERE age > 20;  -- 在串行化级别下也会加锁
-- 其他事务的插入会被阻塞

COMMIT;
```
##### 方案三：业务层控制
```java
// 在Java代码中控制事务边界
@Transactional
public void updateAdultUsers() {
    // 方法开始立即进行当前读锁定
    List<User> users = userMapper.selectAdultsForUpdate();
    
    // 执行业务逻辑，此时数据视图是稳定的
    userMapper.updateAdultStatus();
    
    // 整个方法在同一个事务中，使用统一的加锁视图
}
```
#### 总结
在MySQL的可重复读隔离级别下，依然会在以下场景产生幻读：
- 混合读写场景：当事务中先执行快照读（普通SELECT），再执行当前读（SELECT FOR UPDATE）时，当前读会看到其他事务已提交的插入，导致前后结果集行数不一致。
- 先查后更新场景：如果先执行范围查询，再执行范围更新，UPDATE语句作为当前读会看到其他事务的插入，导致更新了'意外'的记录。
这是因为MVCC只能保证快照读的一致性，而当前读会读取最新的已提交数据。要完全避免幻读，需要在事务开始后立即用SELECT FOR UPDATE锁定查询范围，或者使用串行化隔离级别。