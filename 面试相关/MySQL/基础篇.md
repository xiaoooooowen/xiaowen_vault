### 一条SELECT语句是怎样执行的？
1. 连接器：建立连接，管理连接，校验用户权限
2. 访问缓存：如果命中查询缓存返回结果，否则向下查询
3. 解析SQL：解析词法语法
4. 执行器
	- 预处理阶段：判断阻断字段是否存在
	- 优化阶段：选择执行效率最高的索引
	- 执行阶段：联合索引引入索引下推避免回表操作提升效率

> 一条SELECT语句的执行主要经历以下几个阶段：
> 
> 1. **连接器**：负责建立和管理客户端连接，进行身份认证和权限校验
> 2. **分析器**：对SQL进行词法分析和语法分析，确保语句正确性
> 3. **优化器**：生成最优执行计划，决定索引使用和连接顺序
> 4. **执行器**：调用存储引擎接口执行查询，包含预处理、权限验证等步骤
> 
> 在执行阶段，存储引擎会利用各种优化技术：
> - **索引下推**：在索引层面提前过滤数据，减少回表次数
> - **覆盖索引**：避免回表操作，直接从索引返回所需数据
> - **MRR优化**：减少随机IO，提高范围查询性能
> 
> 最终，数据通过存储引擎→执行器→客户端的路径返回结果。
### MySQL一条记录是如何存储的？
MySQL使用InnoDB存储引擎，存储结构自顶向下分别是段，区，页，行
### 段
- 数据段
- 索引段
- 回滚段
### 区
为了顺序I/O，把64张页划分到一个区，大小为1MB
### 页
InnoDB以页为单位进行读写，每页大小位16KB
### 行
现在使用Compact格式，
```C
变长字段长度列表|NULL值列表|记录头信息|row_id|trx_id|roll_ptr|其余真实数据
```
- 变长字段列表：记录不同的varchar(n)列有多少个。变长字段的真实数据占用的字节数按照列的顺序逆序排放，可以让位置靠前的的记录的真实数据和数据对应的字段长度信息可以在一个CPU CacheLine上，提高CacheLine利用率
- NULL值列表：记录这一行有多少NULL值，用二进制逆序表示，第几位是NULL对应的逆序位就是1，存储十六进制数
- 记录头信息：
	- delete_mask:标记是否被删除
	- next_record:下一条记录的位置，指向下一条的记录头信息和row_id之间
	- record_type:当前记录的类型，0表示叶子记录，1表示非叶子记录

### 行溢出后，InnoDB怎么处理
默认Dynamic格式下，将大部分数据转移到溢出页，真实数据部分只存储20字节长度的指针指向溢出页
1. **连接器**：建立连接，验证用户权限，分配线程资源。
2. **解析器**：进行词法和语法分析，生成解析树，并检查表/字段是否存在。
3. **优化器**：基于成本模型生成并选择最优执行计划（如索引选择、连接顺序等）。
4. **执行器**：根据执行计划，调用存储引擎接口逐行获取数据；对无法下推的条件在 Server 层过滤，并处理排序、分组等逻辑。
5. **InnoDB 存储引擎**：
    - 检查所需数据页是否在 **Buffer Pool** 中；
    - 若不在，则从磁盘加载到 Buffer Pool；
    - 根据索引定位记录，结合 MVCC 机制返回符合当前事务可见性的数据版本。