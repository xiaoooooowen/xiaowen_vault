### 什么场景下使用过锁？整个加锁的流程是什么样的？
1. **利用互斥锁防止缓存击穿**
	- 缓存击穿指的是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。解决办法就是利用互斥锁保证同一时刻只有一个线程执行操作数据库的逻辑
	- **加锁流程**：
		- 从Redis查询目标数据，判断是否命中
			- 如果命中，返回数据
			- 如果没有命中，尝试获取分布式锁
		- 判断是否获取到锁
			- 若没有获取到锁
				- 再次查询Redis缓存，应为此时可能有其他线程重建完成
				- 如果缓存命中，返回数据
				- 如果仍然未命中休眠一段时间后重试
			- 若获取到锁
				- 再次检查缓存是否已存在（双重检查）
				- 如果命中，直接返回
				- 如果未命中，执行以下操作
					- 查询数据库获取信息
					- 将数据写入Redis（设置正常过期时间）
					- 释放锁（使用Lua脚本确保原子性/在finally块中释放锁，确保异常时也能释放）
					- 返回数据
	
2. **高并发下的库存超卖问题**
	- 在下单这个业务中，如果有A、B两个线程同时进行下单操作，线程A查询到库存不为0时，准备执行库存扣减操作，但此时线程B也进行查询库存操作，这时会查到未扣减库存的库存值，线程B认为存在库存，也会执行库存扣减操作，这就会导致库存超卖问题
	- 为了解决这个问题，我们使用一个乐观锁来解决这个问题，主要逻辑为:只要我扣减库存时库存是>0的，就执行扣减
		- **为什么设置成>0**?
			因为如果判断条件设置成扣减库存时的库存和之前查询到的库存是否一样的话，就会导致同一时间的许多线程失效，只有一个线程扣减成功，影响效率。
### 这个锁是怎么实现的？用了 Redis 的 setnx？
1. 防止缓存击穿
	使用SETNX方法，该方法含义是如果Redis中没有这个Key，则插入成功，返回1，在stringRedisTemplate返回true，如果已经有Key，则返回0，在stringRedisTemplate返回false。成功插入Key的线程就认为是获得到锁的线程
```java
 
private boolean tryLock(String key) {
    Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.SECONDS);
    return BooleanUtil.isTrue(flag);
}

private void unlock(String key) {
    stringRedisTemplate.delete(key);
}

public Shop queryWithMutex(Long id)  {
        String key = CACHE_SHOP_KEY + id;
        // 1、从redis中查询商铺缓存
        String shopJson = stringRedisTemplate.opsForValue().get("key");
        // 2、判断是否存在
        if (StrUtil.isNotBlank(shopJson)) {
            // 存在,直接返回
            return JSONUtil.toBean(shopJson, Shop.class);
        }
        //判断命中的值是否是空值
        if (shopJson != null) {
            //返回一个错误信息
            return null;
        }
        // 4.实现缓存重构
        //4.1 获取互斥锁
        String lockKey = "lock:shop:" + id;
        Shop shop = null;
        try {
            boolean isLock = tryLock(lockKey);
            // 4.2 判断否获取成功
            if(!isLock){
                //4.3 失败，则休眠重试
                Thread.sleep(50);
                return queryWithMutex(id);
            }
            //4.4 成功，根据id查询数据库
             shop = getById(id);
            // 5.不存在，返回错误
            if(shop == null){
                 //将空值写入redis
                stringRedisTemplate.opsForValue().set(key,"",CACHE_NULL_TTL,TimeUnit.MINUTES);
                //返回错误信息
                return null;
            }
            //6.写入redis
            stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_NULL_TTL,TimeUnit.MINUTES);
        }catch (Exception e){
            throw new RuntimeException(e);
        }
        finally {
            //7.释放互斥锁
            unlock(lockKey);
        }
        return shop;
    }
```
### 为什么用 SETNX 而不是 SET？两者区别？
核心原因在于 **原子性**。

`SETNX`（Set if Not eXists）是一个原子操作，它将“判断 key 是否存在”和“设置 key”合并为一个不可分割的动作。这确保了在高并发环境下，多个客户端同时尝试获取锁时，**只有一个能成功**，从而保证了锁的互斥性。

如果使用普通 `SET` 命令，我们必须先执行 `GET` 判断锁是否存在，再决定是否 `SET`。这两个步骤是非原子的，在“检查之后、设置之前”的极短时间内，另一个客户端可能已经设置了锁，导致多个客户端都认为自己获得了锁——这就是典型的竞态条件（Race Condition），会破坏分布式锁的安全性。
（简历修改）
此外，仅使用 `SETNX` 还不够，因为它不支持设置过期时间。如果客户端获取锁后发生宕机或异常，无法主动释放，就会造成**死锁**，其他所有客户端都无法再获取该锁。

因此，在现代 Redis 实践中，我们推荐使用：
```
SET lock_key unique_value NX EX max_seconds
```

这个命令在一个原子操作中完成了：

- `NX`：只有 key 不存在时才设置（类似 SETNX）；
- `EX`：设置秒级过期时间；
- 同时写入一个**唯一值**（如 UUID），用于后续安全释放。

这样既保证了互斥性，又避免了死锁风险。

更进一步，在释放锁时，也必须保证原子性：不能简单执行 `DEL`，否则可能发生“误删”。正确的做法是使用 Lua 脚本，先校验 value 是否匹配当前客户端的唯一标识，再执行删除，确保不会干扰其他客户端持有的锁。

对于更高可靠性的需求，也可以考虑 Redlock 算法或多节点协调服务（如 ZooKeeper）来实现分布式锁
### 乐观锁和悲观锁
- 悲观锁：悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等
- 乐观锁：乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas
	- 乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 == 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值

### 一人一单问题如何解决？
