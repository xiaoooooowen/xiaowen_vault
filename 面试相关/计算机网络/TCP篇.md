### 什么是TCP协议？它有什么特点？

- TCP是传输层协议，他提供面向连接、可靠、全双工的字节流服务，广泛应用于HTTP、FTP、SMTP等对可靠性要求高的场景，它的主要特点有：
	1. 面向连接：通过三次握手建立连接，客户端和服务端交换SYN和ACK报文，同步初始序列号，确保双方都具备收发能力。三次握手还能防止历史连接请求造成资源浪费。
	2. 可靠传输：通过一下机制保证数据不丢失、不重复、按序到达
		1. 序号与确认机制：每个字节都有确认机制，接收方返回确认
		2. 超时重传：发送发未收到ACK会定时重发
		3. 数据检验：使用校验和监测数据是否受到损坏
	3. 流量控制：使用滑动窗口机制，接收方在ACK中通告自己的接收窗口大小，发送方据此控制发送速率，防止接收方缓存区溢出
	4. 拥塞控制：主要算法包括慢启动，拥塞避免，快重传，快恢复。发送方根据丢包等信号动态调整拥塞窗口
	5. 全双工通信：双方可以同时收发数据
	6. 字节流模式：不保留信息边界，会导致粘包和拆包问题，需要应用层设计协议来处理。==不熟悉==
---
### TCP是如何建立双向连接的？
- TCP通过三次握手建立双向连接：
	- 第一次：
		客户端选择一个初始序列号`seq = x` ,向服务器发送`SYN = 1` 的报文段，进入SYN_SENT状态。此时客户端表明我要开始通信了，我的起始序号是x
	- 第二次：
		服务器接收到SYN请求后，确认客户端的序列号，同时选择自己的起始序列号，回复一个`seq = y ，ack = x + 1`的报文段，进入SYN_RCVD状态。这表示：“我收到了你的请求，你的下一个请求应该从`x + 1`开始；我也准备好通信了，我的起始序列号是y。”
	- 第三次：
		客户端收到SYN + ACK后 ，向服务端发送`ack = y + 1`的确认报文，进入ESTABLISHED状态。服务器收到后也进入ESTABLISHED状态
		*大写ACK和SYN是标志位，确认后面的ack有效的*
	至此双方都完成了：
	- 发送并得到了对方对自己的序列号确认
	- 验证了对方的接受能力和自己的发送能力
	- 协商好了后续数据传输的起始序号
	这也说明了为什么不是两次握手，是因为服务端要确认客户端的接受能力是正常的
# TCP三次握手与四次挥手
## TCP基本认识
### TCP头格式有哪些？
- 序列号：
- 确认应答号：
- 控制位：（为1时）
	- ACK：确认应答的字段变为有效
	- RST：TCP连接出现异常必须断开连接
	- SYN：表示请求建立连接
	- FIN：希望断开连接
### 为什么需要TCP连接？TCP协议工作在哪一层？
### 什么是TCP？
### 什么是TCP连接？
socket、序列号、窗口大小
### 如何唯一确定一个TCP连接？
#### TCP连接的最大值？
### UDP和TCP有什么区别？分别的应用场景是？
### UDP和TCP可以使用同一个端口吗？

## TCP连接建立
### TCP三次握手过程是什么样的？
- 第三次握手可以携带数据
### 如何在Linux系统中查看TCP状态？
### 为什么是三次握手？不是两次四次？
1. 避免历史连接
2. 同步双方初始序列号
3. 避免资源浪费：不能一有SYN报文服务端就建立连接
### 为什么每次建立TCP连接时，初始化的序列号都要求不一样呢？
- 防止接收历史报文
- 防止黑客伪造相同的序列号的报文被对方接受
### 初始序列号ISN是如何随机产生的？
### 既然IP层会分片，为什么TCP层需要MSS？
- MTU：一个网络包的最大长度 1500byte
- MSS：一个网络包容纳TCP数据的最大长度
IP分片效率低，TCP分好不浪费资源
### 第一次握手丢失了，会发生什么？
- 重传三次
### 第二次握手丢失了，会发生什么？
- 服务端客户端各自重传
### 第三次握手丢失了，会发生什么？
- 服务端没有收到，重传几次，断开连接
### 什么是SYN攻击？如何避免？
- 浪费服务端的半连接队列
todo

## TCP连接断开

### TCP四次挥手是怎样的？
### 为什么挥手需要四次？
### 第一次挥手丢失了，会发生什么？
- 重传几次直接关闭
### 第二次挥手丢失了，会发生什么？ 
- 重传几次直接关闭
### 第三次挥手丢失了，会发生什么？
- 重传几次直接关闭
### 第四次挥手丢失了，会发生什么？
TIME_WAIT状态
- 服务端重传几次断开
- 客户端2MSL定时，超过2MSL断开
### 为什么TIME_WAIT等待时间是2MSL？
确认ACK是否被他收到
### 为什么需要TIME_WAIT状态？
主动发起关闭连接的一方，才会有TIME_WAIT状态
### TIME_WAIT过多有什么危害？
### 如何优化TIME_WAIT?
### 服务器出现大量TIME_WAIT状态的原因有哪些？
### 如果建立了连接，但是客户端突然出现故障了怎么办？
### 如果已经建立了链接，但是服务器进程崩溃会发生什么？

## Socket编程
# TCP重传、滑动窗口、流量控制、拥塞控制
## 重传机制
- 超时重传
	- 数据包丢失
	- 确认应答丢失
	- RTO略大于RTT
- 快速重传：收到三个相同的ACK，重传。但无法确定重传那几个
- SACK：选择性确认
	- 在TCP头部【选项】字段里面加一个SACK，将已经收到的数据的信息发送给发送方
- D-SACK
	- 使用SACK告诉发送方哪些数据被重复接受了
	- 可以让发送方知道，是发出去的包丢了还是还是接收方的ACK包丢了
	- 可以知道是不是发送方的数据包网络延迟了
	- 可以知道网络中是不是把发送方的数据包复制了
## 滑动窗口
一次性多发送几个数据包，由窗口大小决定，使用累计确认
### 发送方的滑动窗口
- snd.wnd
- snd.una:已发送但未确认的第一个字节的序列号
- snd.nxt：未发送但可以发送的第一个字节的序列号
- 可用窗口大小 = snd.wnd - (snd.nxt - snd.una)
### 接收方滑动窗口
- rcv.wnd
- rcv.nxt：它指向期望发送方发来的下一个数据段的序列号
## 流量控制
发送端的窗口发送完之后变小，接收到ack后扩大窗口大小
### 操作系统缓冲区和滑动窗口的关系
TCP规定不允许同时减少缓存又收缩窗口，而是先收缩窗口，过段时间再减少缓存，这样就避免了丢包的情况
## 窗口关闭
如果窗口大小为0时，就会阻止发送方给接收方传递数据，直到窗口变为非0为止
### 窗口关闭的潜在风险
接收方处理完数据后，窗口增大了。发送报文告诉发送端此时的窗口大小，但是这条报文丢失了，就会造成死锁。发送方一直在等待接收方的报文，接收方在等待发送方的报文
### 如何解决
只要TCP连接一方收到窗口大小为0的报文，就会启动持续计时器
如果计时器超时，就会发送窗口探测报文，另一方确认报文时，给出自己的窗口大小
- 如果仍然是0，再次启动计时器
- 不为0，发送数据
## 糊涂窗口
接收方处理速度过慢，每次接收到的大部分数据都在缓冲区，使得接收窗口越来越小，每次发送的数据也越来越小
- 接收方不在通知小窗口
	- 当窗口大小小于`min(MSS,缓存空间/2)`时，发送窗口大小为0的报文，之后满足大于上面任意一个条件之后，重新接收数据
- 发送方不要发送小数据
	- 使用`Nagle`算法，满足下面任意一个条件
		1. 窗口大小大于等于MSS，且数据大小大于等于MSS
		2. 收到之前的ACK包



## 拥塞控制
网络差-》丢包-》重传-》网络更差-》再次丢包-》再次重传......
避免发送方的数据填满整个网络

加入拥塞窗口`swnd`,发送窗口 = min(cwnd , rwnd),只要网络中出现拥塞，窗口就会变大，没有拥塞，就会变小

**如何判断网络有没有拥塞**
发生超时重传
**如何控制**
- 慢启动
- 拥塞避免
- 拥塞发生
- 快速恢复
### 慢启动
发送方每收到一个ACK，拥塞窗口+1
通过 `ssthres`控制
- 小于时，慢启动
- 大等于时，拥塞避免算法
### 拥塞避免算法
一般`ssthres`大小为65535大小
没收到一个ACK，cwnd增加1/cwnd

增长到一定大小，又会拥塞，此时使用拥塞发生算法

### 拥塞发生
两种重传机制
- 超时重传
	- `ssthres`设置为cwnd/2
	- cwnd重置为1
	- 然后重新开始慢启动
- 快速重传，只丢了一小部分数据
	- cwnd=cwnd/2
	- ssthres = cwnd
	- 进入快速恢复算法
### 快速恢复
- 拥塞窗口cwnd = ssthresh + 3
- 重传丢失的数据包
- 收到重复的数据包ACK，cwnd + 1
- 收到新的数据包ACK，设置cwnd为第一步中的ssthresh，再次进入拥塞避免状态
# 如何理解TCP是面向字节流的协议？
## 如何理解字节流
### 为什么说UDP是面向报文的协议？
通过UDP协议传输，操作系统发不会对消息拆分
### 为什么TCP是面向字节流的协议？
使用TCP，消息会因为窗口大小和发送缓冲区大小被拆分成不同大小的多个TCP段
所以不能认为一个用户消息对应一个TCP报文。
应用程序解决
## 如何解决粘包？
- 固定长度的消息
- 特殊字符作为边界：回车、0换行
- 自定义消息结构:用一个变量表示大小，接收方收到结构体头，根据长度划分数据包，接收到完整的数据包，组装成完整的用户消息处理

# 为什么TCP每次建立连接时，初始化序列号都不一样？
**主要是为了防止历史报文被下一个相同四元组接收**

## TCP四次挥手TIME_WAIT状态不是会持续2MSL时长，历史报文不早在网络中消失了吗？
因为不能保证每次断开连接都是四次挥手
- 客户端和服务端建立一个 TCP 连接，在客户端发送数据包被网络阻塞了，然后超时重传了这个数据包，而此时服务端设备断电重启了，之前与客户端建立的连接就消失了，于是在收到客户端的数据包的时候就会发送 RST 报文。
- 紧接着，客户端又与服务端建立了与上一个连接相同四元组的连接；
- 在新连接建立完成后，上一个连接中被网络阻塞的数据包正好抵达了服务端，刚好该数据包的序列号正好是在服务端的接收窗口内，所以该数据包会被服务端正常接收，就会造成数据错乱。
## 初始化序列好不一样不是也会发生这样的问题吗？
初始化序列号不一样，就有大概率因为历史报文序列号不在接收窗口内，不被接收
## 随机生成序列号，不是还有可能相同吗？
RFC793 提到初始化序列号 ISN 随机生成算法：ISN = M + F(localhost, localport, remotehost, remoteport)。

- M 是一个计时器，这个计时器每隔 4 微秒加 1。
- F 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值，要保证 hash 算法不能被外部轻易推算得出。

可以看到，随机数是会基于时钟计时器递增的，基本不可能会随机成一样的初始化序列号。
TCP头部还会有时间戳Recent TSval
TODO：时间戳也会回绕，怎么解决

# SYN报文什么情况下会被丢弃？
- 开启 tcp_tw_recycle 参数，并且在 NAT 环境下，造成 SYN 报文被丢弃
- TCP 两个队列满了（半连接队列和全连接队列），造成 SYN 报文被丢弃
# 已经建立连接的TCP收到SYN会发生什么？
要伪造一个能关闭 TCP 连接的 RST 报文，必须同时满足「四元组相同」和「序列号是对方期望的」这两个条件。

今天给大家介绍了两种关闭 TCP 连接的工具：tcpkill 和 killcx 工具。

这两种工具都是通过伪造 RST 报文来关闭 TCP 连接的，但是它们获取「对方下一次期望收到的序列号」的方式是不同的，也正因此，造就了这两个工具的应用场景有区别。
- tcpkill 工具只能用来关闭活跃的 TCP 连接，无法关闭非活跃的 TCP 连接，因为 tcpkill 工具是等双方进行 TCP 通信后，才去获取正确的序列号，如果这条 TCP 连接一直没有任何数据传输，则就永远获取不到正确的序列号。
- killcx 工具可以用来关闭活跃和非活跃的 TCP 连接，因为 killcx 工具是主动发送 SYN 报文，这时对方就会回复 Challenge ACK，然后 killcx 工具就能从这个 ACK 获取到正确的序列号。

# 四次挥手中收到乱序的FIN包会如何处理？

在 FIN_WAIT_2 状态时，如果收到乱序的 FIN 报文，那么就会被加入到「乱序队列」，并不会进入到 TIME_WAIT 状态。

等再次收到前面被网络延迟的数据包时，会判断乱序队列有没有数据，然后会检测乱序队列中是否有可用的数据，如果能在乱序队列中找到与当前报文的序列号保持顺序的报文，就会看该报文是否有 FIN 标志，如果发现有 FIN 标志，这时才会进入 TIME_WAIT 状态。
# 在TIME_WAIT状态的链接里，收到SYN后会发生什么？


针对这个问题，关键是要看 SYN 的「序列号和时间戳」是否合法，因为处于 TIME_WAIT 状态的连接收到 SYN 后，会判断 SYN 的「序列号和时间戳」是否合法，然后根据判断结果的不同做不同的处理。

先跟大家说明下，什么是「合法」的 SYN？

- **合法 SYN**：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要大，并且 SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要大。
- **非法 SYN**：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要小，或者 SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要小。

上面 SYN 合法判断是基于双方都开启了 TCP 时间戳机制的场景，如果双方都没有开启 TCP 时间戳机制，则 SYN 合法判断如下：

- **合法 SYN**：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要大。
	- 重用此寺院组连接，跳过2MSL转变为SYN_RECV状态，接着就能进行建立连接的过程
- **非法 SYN**：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要小。
	- 再回复一个第四次挥手的ACK报文，客户端收到后，发现并不是自己期望收到的确认好，就返回RST报文给服务端

# TCP连接，一端断电和进程崩溃有什么区别？
## 主机崩溃

# 拔掉网线之后，原本的TCP连接还存在吗？
# tcptwreuse为什么默认是关闭的？
# HTTPS中TLS和TCP能同时握手吗？
# TCP keepalive和HTTP keep-alive是一个东西吗？
# TCP协议有什么缺陷？
# 如何基于UDP实现可靠传输？
# TCP和UDP可以使用同一个端口吗？
# 服务端没有listen，客户端发起连接建立，会发生什么？
# 没有accept，能建立连接吗？
# 用不了TCP协议，数据一定不会丢吗？
# TCP四次挥手，可以变成三次吗？
# TCP的序列号和确认号是如何变化的？






