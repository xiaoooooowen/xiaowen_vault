# HTTP常见面试题
## HTTP基本概念
### 介绍一下HTTP协议是什么？

- http协议又叫超文本传输协议，是一种在应用层上使用的协议，用于在客户端和服务端传输超文本数据，他有下面的这几个特点：
	1. 基于TCP/IP协议,保证可靠传输
	2.  提供多种方法（GET/POST），和多种响应状态码（404,100)
	3. 使用请求响应模型，客户端发送请求，服务端响应请求
	4. 是无状态协议，不保存上下文，可以通过Cookie、Session、JWT维持状态
	从他自1996年诞生以来，经历了多次版本更新：
	- HTTP1.0，这个版本具备了http协议基本的功能，比如：
		- 请求头和响应头
		- 状态码
		- 请求方法：如post，head，get
		- 通过content-Type头，可以传输图片，视频，HTML文件等
		但他有一个重大的问题：
		- **连接无法复用**：每一次请求都需要建立单独的TCP连接，导致页面加载的高延迟，效率低。
	- 因此，在HTTP1.0基础上，改进出了HTTP1.1，他新增了下面几个特性：
		1. 持久连接：默认保持链接打开，允许多个请求和响应在同一个连接上桉顺序执行，减少TCP握手挥手带来的资源消耗
		2. 管道化：允许客户端在同一个连接上发送多个请求，而无需等待上一个请求的响应返回。
		3. 加入功能强大的缓存控制 ==不熟悉==
		4. 分块传输编码==不熟悉==
		5. 主机头==不熟悉==
		遗留的问题：
		- 队头阻塞：在默认的持久连接中，请求依然是顺序的，但是如果处理一个请求的时间过长，会阻塞后续所有的请求
		- 头部荣誉：每个请求携带大量重复的头部，比如Cookie、Uesr-Agent==不熟悉==，造成带宽的浪费。
	- 在2015年，诞生了HTTP/2协议，它有如下的新特性：
		1. 二进制协议：不再是纯文本协议，而是采用二进制分帧层。解析更高效
		2. 多路复用：彻底解决之前版本的队头阻塞问题。在同一个TCP连接上，每个请求响应被分解成带有唯一ID的帧，在接受端根据ID重新组装
		3. 头部压缩：使用HPACK算法对HTTP头部进行压缩，大大减少头部开销
		4. 服务器推送：将客户端需要的资源主动推送给客户端，无需请求，减少延迟
		5. 流优先级：允许客户端为请求分配优先级，提示服务器哪些资源更重要
		但他依然会有TCP带来的队头传输阻塞问题
	- 最新的版本是在2022年使用的HTTP/3，他在底层进行了重大变动：
		1. 从基于TCP转向基于QUIC，而QUIC基于UDP==不熟悉==， 解决TCP队头阻塞问题。QUIC在传输层实现了多路复用，在QUIC层发生packet loss ，只会影响该数据包对应的流，其他流不受影响
		2. 拥有更快的连接建立；只需要0或1RTT建立连接==不熟悉==
		3. 当网络状态变化时，由于QCID使用连接ID而不是IP和端口来标识连接，因此连接可以无缝衔接
	以上就是我对HTTP协议的大概了解
**优化**
HTTP协议是应用层的超文本传输协议，它采用请求-响应模型且是无状态的，基于TCP/IP协议族，用于在万维网上传输数据。
它的发展史本质上是围绕提升性能和降低延迟的演进：
- **HTTP/1.0** 奠定了基础，但最大的问题是每个请求都需要新建一个TCP连接，性能很差。
- **HTTP/1.1** 的核心改进是持久连接，允许在同一个连接上按序处理多个请求/响应。但它引入了队头阻塞问题，即一个慢请求会阻塞后续所有请求。同时，头部信息重复传输，较为冗余。
- **HTTP/2** 是一次重大升级。它通过二进制分帧层实现了真正的多路复用，彻底解决了HTTP层的队头阻塞。同时，使用HPACK算法压缩头部，并支持服务器推送等特性，性能大幅提升。但其底层仍基于TCP，无法避免TCP传输层的队头阻塞。
- **HTTP/3** 就是为了解决TCP的瓶颈而生。它弃用TCP，转而使用基于UDP的QUIC协议。QUIC在传输层内置了多路复用，单个数据包的丢失不会影响其他流。同时，实现了更快的0-RTT/1-RTT连接建立，并且使用连接ID而非IP+端口来标识连接，使得在网络切换（如Wi-Fi换4G）时能无缝保持连接。
可以说，HTTP 的演进史，就是一部不断突破网络性能瓶颈的工程创新史。如今，HTTP/2 和 HTTP/3 已成为现代 Web 架构的标配，尤其在高并发、移动端场景下发挥着关键作用

### HTTP常见状态码有哪些？
- `1xx`类状态码是提示信息，处理协议的一种中间状态
- `2XX`类状态码表示服务器成功处理了客户端的请求
	- 【200 OK】 一切成功
	- 【204 No Content】成功状态码，响应头没有body信息
	- 【206 Partial Content】应用于HTTP分块下载或断点续传，表示响应返回的只是部分数据
- `3xx`类状态码表示客户端请求的资源发生了变动，需要客户端用新的URL重新发送请求获取资源，也称重定向
	- 【301 Moved Permanently】永久重定向，资源已经不存在了
	- 【302 Found】临时重定向，资源还存在，只是需要另外一个URL访问
	- 【304 Not Modified】缓存重定向
- `4xx`类状态码表示客户端发送的报文有误，服务器无法正常处理
	- 【400 Bad Request】表示客户端请求的报文有误
	- 【403 Forbidden】服务器禁止访问资源
	- 【404 Not Found】表示请求的资源在服务器上不存在或没找到
- `5xx`类状态码表示客户端请求报文正常，但是服务器内部发生了错误，属于服务器端的错误码
	- 【500 Internal Sever Error】和400一样，不知道错误类型
	- 【501 Not Implemented】表示客户端请求的功能还不支持
	- 【502 Bad Gateway】服务器作为网关或者代理时返回的错误码
	- 【503 Service Unavailable】表示当前服务器很忙，暂时无法响应客户端

### HTTP常见字段有哪些？
- Host：客户端请求指定服务器域名
- Content Length：表明此次回应的数据长度，解决粘包问题
- Connection：用于客户端要求服务器使用【HTTP长连接机制】，以便其他请求复用
  老版本HTTP需要指定Connection为keep-alive
- Content-Type：服务器告诉客户端返回的数据类型
- Content-Encoding：表示服务器使用了什么压缩格式
### HTTP协议有哪些常见方法？

- get方法：用于获取资源，他是安全（不改变服务器状态）且幂等的（多次执行效果相同）。参数通常放在URL查询字符串中
- post方法：用于提交数据，通常用于创建新资源。他既不安全，也不幂等——每次提交可能创建一个新资源（比如发表评论）。数据放在请求体中
- put方法：用于完整更新一个资源，用请求体中的数据替换目标资源的状态。他是幂等的。如果资源不存在且允许，它可以用于创建，这种创建被称为幂等创建
- patch方法：局部更新资源，比如仅修改用户昵称。通常不是幂等的，取决于实现
- delete方法：删除资源。它是幂等的——删除一个不存在的资源仍然返回成功
- head方法：只获取响应头，不返回body，常用于检查资源是否存在
- options方法：查询服务器支持哪些HTTP方法

###  GET 和 POST 最核心的区别是什么？

 - 最核心的区别在于他们的设计语义。
	1. get的语义是获取，他是一个安全且幂等的操作。安全意味着他不应该对服务器数据产生副作用，主要用于查询。因此，他的参数会附在URL后面，可以被缓存收藏为书签。
	2. post的语义是提交，他是一个不安全且不幂等的操作。它用于向服务器提交数据，通常会改变服务器状态，因此，他的请求放在请求体里，默认不会被缓存。
	这里所说的安全性，指的是语义上的安全无副作用，而不是传输安全。无论是GET还是POST在HTTP下都是明文传输，真正的安全需要HTTPS==不熟悉==来保障。
	此外幂等性也很重要，用户刷新页面时，浏览器可以自动重发GET请求而不用担心副作用，但post请求会弹出确认框，避免重复提交，比如下单场景。

## HTTP缓存技术
### HTTP缓存有哪些实现方式？
- 强制缓存
	- Cache-Control，相对时间
	- Expries，绝对时间
- 协商缓存
	- 客户端和服务器协商过后，通过协商结果判断是否使用本地缓存
	- 第一种：请求头部中的`If-Modified-Since`字段和响应头部中的`Last-Modified`
	- 第二种：请求头部中的`If-None-Match`字段和响应头部中的`ETag`
	- `Etag`优先级更高
- 使用ETag字段的协商缓存过程：
	- 当浏览器第一次请求访问服务器资源时，服务器在返回资源时，会加上唯一的ETag字段，这个ETag是根据资源生成的
	- 当浏览器再次请求访问服务器中的资源时，首先会检查强制缓存是否过期
		- 没过期，直接使用本地缓存
		- 过期了，在Request头部加上If-None-Match字段，字段内容是该资源的ETag，再次发送请求
	- 当服务器再次收到请求后，检查请求中的ETag值是否和当前请求的资源生成的唯一标识进行比较
		- 相同，返回304
		- 不相同，返回新的资源，更新ETag

## HTTP特性
### HTTP/1.1的忧点有哪些？
1. 简单
2. 灵活和益于拓展
3. 应用广泛和跨平台
### HTTP/1.1的缺点有哪些？
1. 无状态的双刃剑
	1. cookie技术
2. 明文传输双刃剑
3. 不安全
### HTTP/1.1的性能如何？
1. 长连接
2. 管道网络运输
3. 
## HTTP与HTTPS
### HTTP和HTTPS有什么区别？
- 明文和加密
- https增加SSL/TLS的握手过程
- 默认端口不一样，80和443
- HTTPS需要向CA申请数字证书，来保证服务的身份是可靠的
### HTTPS解决HTTP的什么问题？
- 窃听风险；获取用户信息
- 篡改风险：强制植入垃圾广告
- 冒充风险：冒充淘宝网站
HTTPS在HTTP层和TCP层增加了SSL/TLS协议
- 信息加密
- 校验机制
- 身份证书
### HTTPS的应用数据是怎么保证完整性的？
- 握手协议
- 记录协议
### HTTPS一定安全可靠吗？ 

# HTTP/1.1如何优化？
- 尽量避免发送HTTP请求
- 需要发送HTTP请求时，考虑如何减少请求次数
- 减少服务器的HTTP响应数据的大小
## 如何避免发送HTTP请求？
缓存
### HTTP缓存有哪些实现方式？
- 强制缓存
	- Cache-Control，相对时间
	- Expries，绝对时间
- 协商缓存
	- 客户端和服务器协商过后，通过协商结果判断是否使用本地缓存
	- 第一种：请求头部中的`If-Modified-Since`字段和响应头部中的`Last-Modified`
	- 第二种：请求头部中的`If-None-Match`字段和响应头部中的`ETag`
	- `Etag`优先级更高
- 使用ETag字段的协商缓存过程：
	- 当浏览器第一次请求访问服务器资源时，服务器在返回资源时，会加上唯一的ETag字段，这个ETag是根据资源生成的
	- 当浏览器再次请求访问服务器中的资源时，首先会检查强制缓存是否过期
		- 没过期，直接使用本地缓存
		- 过期了，在Request头部加上If-None-Match字段，字段内容是该资源的ETag，再次发送请求
	- 当服务器再次收到请求后，检查请求中的ETag值是否和当前请求的资源生成的唯一标识进行比较
		- 相同，返回304
		- 不相同，返回新的资源，更新ETag
## 如何减少HTTP请求次数？
- 减少重定向请求次数；
- 合并请求；
- 延迟发送请求
### 减少重定向请求次数
资源不存在，需要更新URL，重定向。将这个任务交给代理服务器，让他直接完成重定向工作，让服务端一次请求获取到资源
### 合并请求
把多个小文件的访问合并成一个大的请求，减少了请求的次数，相当于减少了重复发送的HTTP头部
合并请求，也能减少TCp连接的数量，省去了TCP握手和慢启动过程耗费的时间

和并请求的几种方式：
- 合并照片
- 合并资源
	- 小资源改变，大资源全部改变
### 延迟发送请求
- 按需获取；

## 如何减少HTTP响应数据的大小？
压缩；
- 无损压缩
- 有损压缩

### 无损压缩
经过压缩后，信息不被破坏，还能完全恢复到压缩之前的模样，适合用于文本文件、程序可执行文件、代码文件
### 有损压缩
更优秀的算法

# HTTPS RSA握手协议解析
## TLS握手过程
通常通过四条消息就可以完成TLS握手，也就是需要2个RTT时延（肯定先建立TCP连接）
## RSA握手过程
### TLS第一次握手
【Client Hello】信息：
 - TLS版本号
 - 支持的密码套件列表
 - 生成的随机数（Server Random）
### TLS第二次握手
收到客户端的【Client Hello】后，确认TLS版本号是否支持，从密码套件中选一个，生成随机数（Sever Random），发送
【Sever Hello】：
- 确认的TLS版本号
- 选择的密码套件【密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法 】
- 生成的随机数
随后，为了表明自己的身份，发送含有数字证书的【Sever Certificate】。然后，发送【Sever Hello Done】消息，目的是告诉客户端，我把该发的都发了。

### 客户端校验证书
客户端如何校验证书
#### 数字证书和CA机构
数字证书包含：
- 公钥
- 持有者信息
- CA对这份文件的数字签名及使用的算法
- 证书有效期
- 额外信息
#### 数字证书签发和验证流程
CA签发证书的过程：
- CA把持有者的所有信息打包，进行Hash计算，得到一个hash值
- CA使用自己的私钥将Hash值加密，生成Certificate Signature ，对证书签名
- 将Certificate Signature 添加在文件证书上，形成数字证书
客户端校验：
- 浏览器使用同样的Hash算法算出一个Hash值
- 浏览器收到证书后用本地集成的公钥解密签名
- 比较两个Hash是否一致
#### 证书链
用户信任根证书，根证书保证中间证书，中间证书保证网站证书，确保根证书的安全性，不然根证书失守，证书链就会出问题
### TLS第三次握手
客户端生成一个新的随机数【pre-master】，用服务器的RSA公钥加密这个随机数，通过【Client Key Exchange】传消息给服务端
服务端收到后，用RSA私钥解密，得到客户端发来的随机数
于是，双方都有了三个随机数，据此生成会话密钥【Master Secret】，然后服务端给客户端发送一个【Change Cipher Spec】，告诉服务端开始使用加密方式发送消息
客户端再发一个【Encrypted Handshake Message （Finished）】 消息，把之前发送的所有数据做一个摘要，再用会话密钥加密一下，让服务器做个验证，验证 加密通信是否可用 和 之前握手信息是否有被篡改过】

### TLS第四次握手
服务器发送给客户端 【Change Cipher Spec】和 【Encrypted Handshake Message （Finished）】 ，双方都验证加密解密没有问题，握手正式完成

## RSA算法的缺陷
**不支持前向加密**
客户端传递随机数给服务端通过公钥加密，服务端收到后，会用私钥解密得到随机数。如果服务端私钥泄露，第三方截获的所有TLS通讯密文都会被破解

**ECDHE**解决这个问题

# HTTPS ECGHE握手解析
## 离散对数
如果对于一个整数 $b$ 和质数 $p$ 的一个原根 $a$， 可以找到一个唯一的指数 $i$，使得： 
$$
a^i \pmod{p} = b
$$
那么指数 $i$ 称为 $b$ 的以 $a$ 为底数的模 $p$ 的**离散对数**。
底数a和模数p是离散对数的公共参数，b是运算出来的真数，i是对数。知道了对数，就可以用上面的公式计算出真数。但反过来很难算出对数
特别是当模数p是一个很大的质数，即使知道底数和真数，也无法计算出离散对数
## DH算法
**DH（Diffie-Hellman）密钥交换原理**：

1. 公开参数：模数 $p$ 和底数 $g$  
2. Alice 选私钥 $a$，发公钥 $A = g^a \bmod p$  
3. Bob 选私钥 $b$，发公钥 $B = g^b \bmod p$  
4. 双方计算共享密钥：  
   - Alice: $s = B^a \bmod p$  
   - Bob: $s = A^b \bmod p$  
   → 结果均为 $g^{ab} \bmod p$

窃听者无法从 $g, p, A, B$ 推出 $s$，因需解离散对数问题（DLP），计算不可行。
## DHE算法
- static DH：有一方的（通常是服务端）私钥是固定的，黑客可以通过截获的海量数据暴力破解出服务端的私钥，之前截获的加密数据都会被破解。不具备前向安全性
- DHE：双方的私钥在每次密钥交换通信时都是随机生成的、临时的，保证了前向安全
## ECDHE算法
DHE因为性能不佳，需要做大量的乘法，因此使用ECDHE算法

**ECDHE（椭圆曲线临时 Diffie-Hellman）原理**：

1. 双方约定公开椭圆曲线参数和基点 $G$  
2. Alice 生成临时私钥 $d_A$，计算公钥 $Q_A = d_A \cdot G$  
3. Bob 生成临时私钥 $d_B$，计算公钥 $Q_B = d_B \cdot G$  
4. 交换公钥后，各自计算共享密钥：  
   - Alice: $S = d_A \cdot Q_B = d_A d_B \cdot G$  
   - Bob: $S = d_B \cdot Q_A = d_B d_A \cdot G$  

✅ 共享密钥相同，且每次会话密钥独立，提供**前向安全性**。  
🔒 安全性基于椭圆曲线离散对数问题（ECDLP），难以从公钥反推私钥。
## ECDHE 握手过程

ECDHE相比RSA握手省去了一个消息往返的时间

### TLS第一次握手
客户端发送 `ClientHello` 消息，包含：
- 支持的 TLS 协议版本
- 客户端随机数（Client Random，32 字节）
- 支持的密码套件列表（如 `ECDHE-RSA-AES256-GCM-SHA384`）
- 支持的椭圆曲线列表（如 secp256r1）

### TLS第二次握手
- `ServerHello`：选定协议版本、密码套件、椭圆曲线，并携带**服务端随机数**（Server Random，32 字节）
- `Certificate`：发送服务器证书链，用于客户端验证服务端身份（证书中包含 RSA 或 ECDSA 公钥）
- `ServerKeyExchange`：包含服务端临时 ECDH 公钥 $Q_S = d_S \cdot G$，以及对该公钥和双方随机数（Client Random + Server Random）的签名（使用证书对应的私钥签名）
- （可选）`ServerHelloDone`（TLS 1.2 中存在，TLS 1.3 已移除）

### TLS第三次握手
客户端执行以下操作：
1. 验证 `Certificate` 的有效性（信任链、域名、有效期等）
2. 使用证书中的公钥验证 `ServerKeyExchange` 中签名的合法性
3. 生成临时私钥 $d_C$，计算临时公钥 $Q_C = d_C \cdot G$
4. 发送 `ClientKeyExchange` 消息，包含 $Q_C$
5. 发送 `ChangeCipherSpec`，表示后续消息将加密
6. 发送`EncryptedHandshakeMessage`,把之前发送的数据做一个摘要，再用对称密钥加密，让服务端做验证
7. 发送加密的 `Finished` 消息（基于协商出的密钥生成，用于验证握手完整性）

### TLS第四次握手
服务端执行以下操作：
1. 使用收到的 $Q_C$ 和自己的临时私钥 $d_S$ 计算共享密钥 $S = d_S \cdot Q_C$
2. 客户端同时计算 $S = d_C \cdot Q_S$
3. 双方使用 **Client Random + Server Random + 共享密钥 $S$** 通过 PRF（伪随机函数）派生出**主密钥**（Master Secret），再生成对称加密所需的会话密钥
4. 服务端发送 `ChangeCipherSpec`
5. 服务端发送加密的 `Finished` 消息
6. 双方开始使用协商好的密钥进行安全应用数据传输

### 安全特性
- 所有临时私钥（$d_C$, $d_S$）在握手完成后立即销毁
- 即使服务器长期私钥未来泄露，也无法解密历史通信
- 实现**完美前向安全性**（Perfect Forward Secrecy, PFS）
### RSA和ECDHE握手过程的区别：
- RSA密钥协商算法不支持前向加密，ECDHE密钥协商算法支持前向加密
- 使用RSA ，TLS完成四次握手后，才能进行数据传输；使用ECDHE，客户端可以不用等服务端最后一次TLS握手，就可以提前发出加密的HTTP数据，节省一个消息的往返时间
- 使用ECDHE，在TLS第二次握手中，会有服务器端发出的`Sever Key Exchange`消息，而RSA握手过程没有此消息

# HTTPS如何优化？
- 硬件优化
- 软件优化
- 协议优化
- 证书优化
- 会话复用
## 分析性能损耗
产生性能损耗的两个环节：
- TLS协议握手过程
- 握手后的对称加密报文传输

TLS协议握手过程不仅增加了网络延迟，握手过程中一些步骤也会增加性能损耗：
- 基于ECDHE，握手过程中客户端和服务端都要临时生椭圆曲线公私钥
- 客户端检验证书，会访问CA获取CRL或OCSP，验证服务器网站是否被吊销
- 双方计算Pre-Master
## 硬件优化
HTTPS是计算密集型，应该优化CPU。（I/O密集型优化内存、磁盘）
## 软件优化
- 软件升级
- 协议优化
## 协议优化
对密钥加密过程进行优化
### 密钥交换算法优化
### TLS升级
TLS1.3完成TLS握手只需要1RTT
- **握手轮次减少**  
  - **TLS 1.2**：完整握手需 **2 个 RTT**（4 次消息往返）  
  - **TLS 1.3**：完整握手仅需 **1 个 RTT**（2 次消息往返），客户端在 `ClientHello` 中就发送密钥共享参数，服务端直接回复加密数据所需密钥
- **支持 0-RTT 模式**（会话恢复时）  
  - 客户端可复用之前会话，在 `ClientHello` 中**直接发送加密的应用数据**（Early Data），实现 **0 次往返延迟**
- **简化密码套件**  
  - 移除不安全或冗余算法（如 RSA 密钥交换、CBC 模式、SHA-1、静态 DH 等）  
  - 仅保留前向安全、AEAD 加密的现代套件（如 AES-GCM、ChaCha20-Poly1305）
- **密钥协商与身份认证合并**  
  - TLS 1.3 将密钥交换和服务器认证整合到前两个消息中，避免额外往返
- **更快的连接建立**  
  - 减少网络延迟对性能的影响，尤其在高延迟网络（如移动网络）中提升显著
## 证书优化
- 证书传输
- 证书验证
### 证书传输优化
减小证书的大小，节约带宽，减少客户端的运算量
服务器证书推荐使用ECDSA，椭圆曲线证书。在相同的安全强度下，ECC密钥长度比RSA短的多
### 证书验证优化
CRL,证书吊销列表：
- 实时性差
- 列表变大，下载变慢
OCSP，在线证书状态协议。向CA发送查询请求，让CA返回证书的有效状态
OCSP Stapling。服务器向CA周期性的查询证书状态，获得带有时间戳和签名的结果并缓存
## 会话复用
TLS握手为了获得加密密钥，如果把首次TLS握手协商的对称加密密钥缓存下来，下次建立HTTPS连接时，直接复用这个密钥，减少TLS握手性能损耗
会话复用分两种：
- Session ID：
	- 客户端和服务端缓存SessionID和会话密钥
	- 服务器储存太多的Session ID ，内存压力变大
	- 因为负载均衡，客户端再次连接可能会命中其他服务器，需要重新建立TLS连接
- Session Ticket：
	- 服务器不再缓存Session ID，将缓存的工作交给客户端。双方首次建立连接时，服务器会加密【会话密钥】作为Ticket发送给客户端，交给客户端缓存该Ticket。下一次请求时，客户端发送Ticket，服务端解密获得会话密钥
	- 要确保集群服务器每一台会话密钥是一致的
	- 不具备前向安全性
	- 难以应对重放攻击
		- 给会话密钥设定一个合理的过期时间
- Pre-shared Key
	- 重连使用一个RTT完成，将Ticket和HTTP请求一次发给服务端
	- 重放攻击危险，设置合理的密钥过期时间
# HTTP/2好在哪？
1. 对于常见的HTTP头部通过静态表和Huffman编码的方式，将体积压缩了一半。还可以建立动态表，将后续的请求头部体积压缩近90%。
   动态表不可以无限大，因为动态表会占用内存
2. HTTP/2实现了Stream并发，多个Stream只需要复用1个TCP连接，节约了握手时间，减少了TCP慢启动阶段对流量的影响。不同的Stream ID可以并发，即使乱序发送帧也没问题，同一个Stream里的帧必须严格有序
   可以根据资源的渲染程序确定优先级
3. 服务器主动推送
# HTTP/3
## HTTP2的问题：
- 队头阻塞，TCP的原因
- TLS和TCP握手延迟
- 网络迁移需要数据连接,TCP连接导致
### QUIC协议的特点
- 没有队头阻塞:每个流互相独立的，某个流发生丢包，不影响其他流
- 更快的连接建立：QUIC内部包含了TLS，它在自己的帧会携带TLS里面的记录。
- 连接迁移：基于TCP，通过四元组（源IP、源端口、目的IP、目的端口）确定一条TCP连接，从4G切换到WIFI，IP地址变换，需要重新建立连接；通过链接ID标记两个端点，即使IP地址变化，根据上下文公式复用原连接。
### HTTP/3协议
通过QPACK使用两个特殊的单向流同步双方的动态表，解决了HTTP
/2的HPACK队头阻塞问题

# HTTP和PRC
- 服务发现
- 底层连接形式：连接池
- 传输的内容
 总结
- 纯裸 TCP 是能收发数据，但它是**无边界的**数据流，上层需要定义**消息格式**用于定义消息边界。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。

- **RPC 本质不算协议，而是一种调用方式**，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，不一定非得基于 TCP 协议。

- 从发展历史来说，HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。

- RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP/1.1 性能要更好，所以大部分公司内部都还在使用 RPC。

- HTTP/2.0 在 HTTP/1.1 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代 RPC。
# HTTP和WebSocket
# 总结

- TCP 协议本身是**全双工**的，但我们最常用的 HTTP/1.1，虽然是基于 TCP 的协议，但它是**半双工**的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 WebSocket 协议。

- 在 HTTP/1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用**定时轮询**或者**长轮询**的方式实现**服务器推送**（comet）的效果。

- 对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 WebSocket 协议。

- WebSocket 和 socket 几乎没有任何关系，只是叫法相似。

- 正因为各个浏览器都支持 HTTP 协议，所以 WebSocket 会先利用 HTTP 协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 WebSocket 的数据格式进行收发数据。
