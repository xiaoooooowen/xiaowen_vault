### 进程和线程有什么区别？
进程和线程是操作系统的核心概念，最根本的区别在于，进程是资源分配的基本单位，而线程是CPU调度的基本单位
从四个方面具体来说：
1. 地址空间和资源隔离：
	- 每个进程拥有独立的虚拟地址空间，包括代码段、数据段、堆和栈，进程之间默认不共享内存
	- 同一个进程内的多个线程则共享该进程的地址空间和系统资源，但每个线程有自己的栈、程序计数器和寄存器状态
2. 通信和同步：
	- 进程间通信必须依赖操作系统提供的机制，如管道、消息队列、共享内存、Socket等。开销较大
	- 线程间通信可以直接读写共享变量，通信高效，但也因此需要通过互斥锁、条件变量等机制进行同步，否则容易引发数据竞争、死锁等问题
3. 健壮性和隔离性：
	- 进程之间相互隔离，一个进程崩溃通常不会导致系统崩溃，不影响其他进程
	- 线程共享进程资源，一旦某个线程出现异常，可能会导致整个进程崩溃
4. 创建和切换开销：
	- 进程创建、销毁和上下文切换涉及到大量资源分配和内核操作，开销大
	- 线程创建、切换开销小，适合高并发场景
因此，在需要频繁创建、紧密通信且任务关联度高的场景下，我们使用多线程；在需要强隔离、高稳定性或任务独立时，我们使用多进程

### 如何避免线程之间的互相干扰？
核心在于保证对共享资源的访问是原子性的、有序的和可见的。主要有两大策略，同步和隔离
1. 同步机制：当线程必须修改和访问共享数据是，我们必须协调他们的访问顺序。
	1. 互斥锁：确保同一时间只有一个线程进入临界区，`synchronized` 关键字或 `ReentrantLock`
	2. 读写锁：允许多个线程同时读，但写线程需要独占访问，适用于读多写少场景，比如缓存系统
	3. 原子变量：使用CPU的原子指令实现无锁编程==不熟悉==
	4. 条件变量：让线程在条件不满足时等待，在条件满足时被唤醒
2. 隔离机制：从根本上避免共享
	1. 线程局部变量：每个线程拥有自己的变量副本
	2. 不可变对象：创建后状态不能被修改的对象
	3. 线程封闭：将数据限制在单个线程内访问
	4. 消息传递：线程间不共享内存，而是通过队列传递消息
3. 工程实践：
	1. 避免死锁的策略
		1. 按固定顺序获取锁
		2. 使用带超时的`tryLock()`
	2. 减小锁的粒度:用多个小锁代替一个大锁
	3. 使用并发容器：ConcurrentMap、BlockingQueue

