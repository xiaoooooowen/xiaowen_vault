---
date: 2025-10-09
tags:
  - 前缀和
  - 栈
  - 队列
  - 堆
  - 字典树
  - 并查集
  - 树状数组
  - 线段数组
---
# 〇、常用枚举技巧
## 枚举右，维护左

对于**双变量问题** ，如$a_i + a_j = t$，可以枚举右边的$a_j$，转变为单变量的问题，也就是在$a_i=t-a_j$，可以用哈希表维护。
>**对于有两个变量的题目，通常可以枚举其中一个变量，把它视作常量，从而转化成只有一个变量的问题**


[1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/description/)
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> idx = new HashMap<>() ;
        for(int j = 0 ; ; j++) {
            int x = nums[j] ;
            if(idx.containsKey(target - x)) {
                return new int[]{idx.get(target - x) , j};
            }
            idx.put(x,j) ;
        }
    }
}
```

[1014. 最佳观光组合 - 力扣（LeetCode）](https://leetcode.cn/problems/best-sightseeing-pair/description/)
```java
class Solution {
    public int maxScoreSightseeingPair(int[] values) {
        int ans = 0;
        int mx = values[0]; // j 左边的 values[i] + i 的最大值
        for (int j = 1; j < values.length; j++) {
            ans = Math.max(ans, mx + values[j] - j);
            mx = Math.max(mx, values[j] + j);
        }
        return ans;
    }
}
```
如何保证$i < j$ ? 先更新`ans`再更新`mx`，让此时j相关的数据还没有加入`values[]`
[3185. 构成整天的下标对数目 II - 力扣（LeetCode）](https://leetcode.cn/problems/count-pairs-that-form-a-complete-day-ii/description/)
```java
class Solution {
    public long countCompleteDayPairs(int[] hours) {
        long ans = 0;
        var cnt = new int[24];
        for (int t : hours) {
            // 先查询 cnt，再更新 cnt，因为题目要求 i<j
            // 如果先更新，再查询，就把 i=j 的情况也考虑进去了
            ans += cnt[(24 - t % 24) % 24];
            //模运算
            cnt[t % 24]++;
        }
        return ans;
    }
}
```
## 枚举中间
[和最小的山形三元数组](https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii)
```java
class Solution {
    public long maximumTripletValue(int[] nums) {
        int n = nums.length;
        int[] suf = new int[n] ;
        suf[ n - 1 ] = nums[ n - 1] ;
        for(int i = n - 2 ; i > 1 ; i--) {//从后往前得到后缀最小值
            suf[i] = Math.max(suf[i + 1], nums[i]);
        }
        long ans = Integer.MIN_VALUE; 
        int pre = nums[0];
        for(int j = 1 ; j < n - 1 ; j++ ) {
            // if(pre < nums[j] && nums[j] > suf[j + 1]) {
                ans = Math.max(ans , (long) (pre - nums[j]) * suf[j + 1]);
            // }
            pre = Math.max(pre, nums[j]);
        }
        return ans < 0  ? 0 : ans ;
    }
}
```
[3583. 统计特殊三元组 - 力扣（LeetCode）](https://leetcode.cn/problems/count-special-triplets/)
```java
class Solution {
    public int specialTriplets(int[] nums) {
        final int MOD = 1_000_000_007 ;
        Map<Integer,Integer> suf = new HashMap<>();
        for(int x : nums) {
            suf.merge(x, 1, Integer::sum); 
        }
        long ans = 0 ;
        Map<Integer,Integer> pre = new HashMap<>();
        for(int x : nums) {
            suf.merge(x, -1, Integer::sum);
            ans += (long) pre.getOrDefault(x * 2, 0) * suf.getOrDefault(x * 2, 0);
            pre.merge(x, 1, Integer::sum);
        }
        return (int) (ans % MOD);
    }
}
```
**merge()函数：**
$$public V merge​(K key, V value, BiFunction<? super V,​? super V,​? extends V> remappingFunction)
$$
如果指定的键尚未与值关联或与`null`关联，则将其与给定的非空值关联。 否则，将相关值替换为给定重映射函数的结果，或者如果结果为`null`则将其删除。 当组合密钥的多个映射值时，该方法可以是有用的。 
>**若键存在则更新值，若不存在则插入新键值对**

**getOrDauflt()函数：**
$$default V getOrDefault​(Object key, V defaultValue)$$
返回指定键映射到的值，如果此映射不包含键的映射，则返回 `defaultValue`

[1930. 长度为 3 的不同回文子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/description/)
字符相关的运算
```java
class Solution {
    public int countPalindromicSubsequence(String s) {
        int[] pre = new int[26];    // 记录当前中间字符左侧的字符频次
        int[] suf = new int[26];    // 记录当前中间字符右侧的字符频次
        int[] has = new int[26];    // 位掩码：记录每个中间字符对应的左右字符组合
        
        // 初始化 suf：统计除首字符外所有字符频次
        for (int i = 1; i < s.length(); i++) {
            suf[s.charAt(i) - 'a']++;
        }

        int ans = 0;
        // 枚举中间字符（从第2个到倒数第2个）
        for (int i = 1; i < s.length() - 1; i++) {
            char midChar = s.charAt(i);
            char leftChar = s.charAt(i - 1);
            
            // 更新 pre：将前一个字符加入左侧频次表
            pre[leftChar - 'a']++;
            // 更新 suf：从右侧频次表移除当前中间字符（避免重复计数）
            suf[midChar - 'a']--;

            // 枚举26个字母作为左右字符
            for (int j = 0; j < 26; j++) {
                // 若字符 j 在左右两侧均出现过
                if (pre[j] > 0 && suf[j] > 0) {
                    // 用位掩码记录组合：has[midChar] 的第 j 位标记为1
                    has[midChar - 'a'] |= (1 << j);
                }
            }
        }

        // 统计结果：计算每个中间字符对应的位掩码中1的个数
        for (int mask : has) {
            ans += Integer.bitCount(mask);
        }
        return ans;
    }
}
```

