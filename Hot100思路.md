## 哈希
### 两数之和
枚举右，维护左，你找到我和我找到你是一样的，两个数字是对称的，不管是前面的找到后面的，还是后面的找到前面的
关键逻辑
```java
for(int j = 0 ; j < nums.length ; j++ ){
	x = nums[j];
	if(map.contiansKey(target - x)){
		return new int[]{j , map.get(target - x)} ;
	}
	map.put(x,j);
}
```
### 字母异位词分组
利用Hash表存储排序后的字符串Key和原来的字符串Value
```java
for(String s : strs){
	char[] sortedS = s.toCharArray();
	Arrays.sort(sortedS);
	String Key = new Sring(sortedS);
	if(!m.contiansKey(sortedS)){
		m.put(Key,new ArrayList<>());
	}
	m.get(Key).add(Key,s);
}
```
### 最长连续序列
把所有数字放入哈希集合中，遍历哈希集合，查找是否存在下一个数，不断更新最大值
关键逻辑
```java
for(int x : nums){
	if(set.contians( x - 1)) continue ;//不是起点，直接忽略
	int y = x ;
	while(set.contians(y)){
		y++;
	}
	ans = Math.max(ans , y - x + 1);
}
```
## 普通数组
### 最大子数组和
递归思想，有一数组`nums`,以数组左端为标的，求一个标的为`i`的子数组的最大值，就是求标的为`i - 1` 的子数组的最大值加`nums[i]`,由此递归，可以得到递归表达式
$$
f[i] = \begin{cases}
\text{nums}[i] & i=0 \\
\max(f[i-1],0)+\text{nums}[i] & i\geq 1
\end{cases}
$$
关键逻辑
```java
for(int x : nums){
            f = Math.max(f,0) + x ;
            ans = Math.max(ans,f) ;
        }
```
### 合并区间
按照左端点排序，判断下一个数组的左端点是否小于当前数组的右端点，如果小于，合并，通过比较两个数组右端点确定合并后的右端点。如果大于，进行下一个合并数组
关键逻辑
```java
for(int[]p : intervals){
	int m = ans.size();
	if(m > 0 && p[0] <= ans.get(m - 1)[1] ){
		ans.get(m - 1)[1] = Math.max(p[1] , ans.get(m - 1)[1]);
	} else {
		ans.add(p);
	}
}
```
### 轮转数组
翻转两次，翻转A+B,翻转A，翻转B，注意对k的处理
关键逻辑
```java
int k %= n;

reverse(nums , 0 , n - 1);
reverse(nums , 0 , k - 1);
reverse(nums , k , n - 1);
```
### 除自身以外数组的成绩
前后缀分解
关键逻辑
```java
int[] pre = new int[n] ;
pre[0] = 1 ;
for(int i = 1 ; i < n ; i++ ){
	pre[i] = pre[i - 1] * nums[i] ;
} 
```
### 缺失的第一个正数
小朋友找座位，一号同学做一号位，二号同学坐二号位...，以此类推，第一个学号和座位编号不一致就对应着第一个缺失的正数，如果都坐在正确的位置上，答案是n + 1 
如果此时是混乱的，就需要给孩子们重新安排座位
关键逻辑
```java
for(int i = 0 ; i < n ; i++ ){
	while(nums[i] > 1 && nums[i] < n && nums[i] != nums[nums[i] - 1]/*避免死循环*/){
		int j = nums[i] - 1 ;
		swap(nums[i] , nums[j]);
	}
}
```
## 矩阵
### 矩阵置零 hard
第一列和第一行是特殊的，用来存储每一行或者每一列是否存在0，用两个boolean值记录第一行和第一列是否有0
```java
for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 ||matrix[0][j] == 0) {
                    matrix[i][j] = 0 ;
                }
            }
        }
        if(isFirstColHasZero){
            for(int[] row : matrix){
                row[0] = 0 ;
            }
        }
        if(isFirstRowHasZero){
            Arrays.fill(matrix[0], 0); //不能用for(int x : martix),因为这种方法是创建了一个副本在修改
        }
```
### 螺旋矩阵
设定一个方向矩阵，顺序为右，下，左，上，通过条件判断掉头，掉头通过（di + 1）% 4 实现
```java
int di = 0 ;
for(int k = 0 ,i = 0 ,j = 0 ; k < m * n ; k++ ){
	ans.add(matrix[i][j]);
	matrix[i][j] = Integer.MAX_VALUE;
	x = i + dirs[di][0];
	y = j + dirs[di][1];
	if( x < 0 || y < 0 || x >= m || y >= n || matrix[i][j] == Integer.MAX_VALUE){
		di = (di + 1) % 4 ;
	}
	i += dirs[di][0];
	j += dirs[di][1];
}
```
### 旋转图像
先进行转置，再进行行的顺序调换
```java
for(int i = 0 ; i < n ; i++ ){
	for(int j = 0 ; j < i ; j++ ){
		temp = matrix[i][j];
		matrix[i][j] = matrix[j][i];
		matrix[j][i] = temp;
	}
}
for(int[] row : matrix){
	for(int i = 0 ; i < m / 2 ; i++ ){
		temp = row[i];
		row[i] = row[m - 1 - i];
		row[m - 1 - i ] = temp;
	}
}
```
### 搜索二维矩阵
按照他的特点，从最后一列比，先淘汰行，再淘汰列
```java
int i = 0 ;
int j = n - 1 ;
while( i < m && j >= 0 ){
	if(mat[i][j] == k) return true;
	if(mat[i][j] < k)
		i++;
	else
		j--;
}
return false;
```
## 双指针
### 移动零
将所有0移动到数组末尾，那就用一个slow始终指向现存的第一个0，fast寻找第一个不为零的，找到后，交换元素，slow加一
```java
int fast = 0 , slow = 0 ;
while(fast < n){
	if(nums[fast] != 0){
		swap(nums[slow],nums[fast]);
		slow++;
	}
	fast++;
}
```
### 乘最多水的容器
前后两个指针维护接水的最大值
```java
while(left < right) {
	int area = (left - right) * Math.min(height[left] , height[right]);
	ans = Math.max(ans , area);
	if(height[left] < height[right]){
		left++ ;
	}else{
		right-- ;
	}
}
```
### 三数之和
先对数组进行排序，从左向右固定一个数字，剩下的元素双指针寻找答案
答案为三个元素和为0
```java
Arrays.sort(nums);
List<List<Integer>> ans = ArraysList<>();
int n = nums.length;

for(int i = 0 ; i < n - 2 ; i++){
	int x = nums[i];
	if(x > 0) break;
	if(x > 0 && x = nums[i - 1]) continue ;
	
	int l = i + 1 ;
	int r = i - 1 ;
	
	while(l < r){
		int sum = x + nums[l] + nums[r];
		if(sum > 0){
			r--;
		}else if {
			l++;
		}else {
			ans.add(Arrays.asList(x , nums[l] , nums[r]));
			r--;
			l++;
			
			while( l < r && nums[i] == nums[i - 1]) l++;
			while( l < r && nums[r] == nums[r + 1]) r--
		}
	}
}
```
### 接雨水
左右两个指针，一个前缀最大值，一个后缀最大值,最大值说明了水平面的最大高度，减去当前木板的长度，累加计算出结果
```java
while(left < right) {
	preMax = Math.max(preMax,height[left]);
	sufMax = math.max(sufMax,height[right]);
	if(preMax < sufmax) {
		ans += pre - height[left];
		left++;
	}else{
		ans += sufMax - height[right];
		right--;
	}
}
```
## 滑动窗口
### 无重复字符的最长子串
记录每个字符最近一次出现的下标，key为字符，value为下标
```java
Map<Character,Integer> map = new Hashmap<>();
char[] ca = s.toCharArray();
for(int right = 0 ; right < s.length() ; right++){
	char cur = ca[right];
	if(map.containsKey(cur) && map.get(cur) > left) {
		left = map.get(cur) + 1 ;
	}
	map.put(cur,right); //更新！！！
	ans = Math.max(ans , right - left + 1)
}
```

### 找到字符串中所有字母异位词
创建一个哈希表，key为经过排序的字符串，value为
## 二叉树
### 二叉树的中序遍历
中序遍历，访问节点数据的操作放在中间，递归调用方法
```java
public void inorder(TreeNode root, List<Integer> res){
	if(root == null){
		return ;
	}
	inorder(root.left,res);
	res.add(root.val);
	inorder(root.right,res);
}
```
### 二叉树的最大深度
自底向上递归
```java
public int maxDepth(TreeNode root){
	if(root == null){
		return 0 ;
	}
	int lDepth = maxDepth(root.left);
	int rDepth = maxDepth(rppt.right);
	return Math.max(lDepth,rDepth) + 1 ;
}
```
### 翻转二叉树
依旧递归
```java
public TreeNode invertTree(TreeNode root){
	if(root == null) {
		return null;
	}
	TreeNode left = invertTree(root.left);
	TreeNode right = invertTree(root.right);
	root.left = right ;
	root.right = left ;
	return root ;
}
```

### 对称二叉树

检查一个二叉树是不是轴对称的
```java
public boolean check(TreeNode p , TreeNode q){
	if(p == null && q == null) 
		return true;
	if(p == null && q == null)
		return false; //上一个判断相当于把那个条件过滤掉了，所以这里没有逻辑问题
	return p.val == q.val && check(p.left , q.rigth) && check(p.right , q.rigth) ;
}
```
### 二叉树的直径
叶子节点距离默认为0，空节点距离默认为-1，其他节点默认为1,直径等于左边长度加右边长度
```java
public int dfs(TreeNode root ){
	if(root == null) 
		return -1 ;
	int lLEN = dfs(root.left) + 1 ;
	int rLEN = dfs(root.right) + 1 ;
	ans = Math.max(ans , lLEN + rLEN ) ; 
	return Math.max(rLEN , lLEN) ;
}
```
### 二叉树的层序遍历
使用一个队列，递归遍历
```java
if(root == null) return List.of() //默认返回空数组

List<List<Integer>> ans = new ArrayList<>();
Queue<TreeNode> q = new ArraryDeque<>();
q.add(root);
while(!q.isEmpty()) {
	int n = q.size() ;
	List<Integer> vals = new ArrayList<>(n); 
	while(n-- > 0 ) {
		TreeNode node = q.poll();
		vals.add(node.val);
		if(node.left != null) q.add(node.left) ;
		if(node.right != null) q.add(node.right) ;
	}
	ans.add(vals);
}
```
### 将有序数组转换为二叉搜索树
二叉树的中序遍历
```java
private TreeNode dfs(int[] nums , int left , int right){
	if(left == right) {
		return null;
	}
	int m = (left + right) >>> 1 ;
	return new TreeNode(nums[m] , dfs(nums , left , m) , dfs(nums , m + 1,right))
}
```
### 验证二叉搜索树
中序遍历得到二叉树数组，检查相邻元素是否严格递增
```java
private long pre = Long.MIN_VALUE;
public boolean dfs(TreeNode root){
    if(root == null) return true;
    if(!dfs(root.left)) return false;
    if(root.val <= pre) return false;
    pre = root.val;
    return dfs(root.right) ;
}
```
## 动态规划
