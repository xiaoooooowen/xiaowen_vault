
## 一、运输层概述与服务模型

### 1.1 运输层核心功能

- **逻辑通信**：为运行在不同主机上的应用进程提供直接通信服务，使进程仿佛直接相连
- **服务定位**：通过**端口号**标识应用进程，实现进程到进程的交付
- **协议选择**：在因特网中，主要提供**TCP**和**UDP**两种协议选择

### 1.2 运输层与网络层关系

|对比维度|网络层|运输层|
|---|---|---|
|**服务范围**|主机到主机通信|进程到进程通信|
|**服务类型**|尽力而为交付|可提供可靠数据传输|
|**协议示例**|IP协议|TCP、UDP协议|

### 1.3 因特网运输层协议对比

|特性|**TCP**|**UDP**|
|---|---|---|
|**连接性**|面向连接|无连接|
|**可靠性**|可靠数据传输|不可靠服务|
|**流量控制**|有|无|
|**拥塞控制**|有|无|
|**速度**|较慢|较快|
|**适用场景**|Web、电子邮件、文件传输|实时视频、DNS查询|

## 二、多路复用与多路分解机制

### 2.1 基本概念

- **多路复用**：从不同套接字收集数据，封装首部信息生成报文段
- **多路分解**：将运输层报文段数据交付到正确套接字

### 2.2 端口号分配机制

- **周知端口号**：0-1023，分配给标准服务（如HTTP:80，SMTP:25）
- **注册端口号**：1024-49151，用于用户进程
- **动态端口号**：49152-65535，临时分配

### 2.3 套接字标识

- **UDP套接字**：由目的IP地址和目的端口号二元组标识
- **TCP套接字**：由源IP、源端口、目的IP、目的端口四元组标识

## 三、无连接运输：UDP协议

### 3.1 UDP特点分析

- **无连接服务**：无需握手，直接发送数据
- **轻量级**：首部仅8字节，开销小
- **无可靠性保证**：不提供确认、重传、排序功能
- **应用场景**：DNS、SNMP、实时多媒体流

### 3.2 UDP报文段结构

```
 0      16      31
|源端口号|目的端口号|
|长度   |检验和   |
|数据（可选）    |
```

### 3.3 UDP检验和机制

- **差错检测**：使用端到端原则，检测比特差错
- **计算方式**：反码求和再取反，覆盖首部和数据

## 四、可靠数据传输原理

### 4.1 可靠数据传输挑战

- **比特差错**：数据传输过程中可能发生的比特错误
- **分组丢失**：中间节点缓存溢出导致分组丢弃
- **分组重排序**：网络路径变化导致乱序到达

### 4.2 自动重传请求(ARQ)协议

#### 4.2.1 核心机制

- **差错检测**：使用检验和、CRC等技术
- **接收方反馈**：ACK（肯定确认）和NAK（否定确认）
- **重传机制**：超时重传和快速重传

#### 4.2.2 协议演进过程
```
流程图：可靠数据传输协议演进
rdt1.0（理想信道） → rdt2.0（比特差错） → rdt2.1（ACK/NAK受损） → rdt2.2（无NAK） → rdt3.0（分组丢失）
```

### 4.3 滑动窗口协议

#### 4.3.1 回退N步(GBN)

- **窗口机制**：发送窗口大小N，接收窗口大小1
- **累积确认**：确认号表示期望接收的下一个字节序号
- **缺点**：单个分组错误导致大量重传

#### 4.3.2 选择重传(SR)

- **独立确认**：每个分组单独确认
- **接收方缓存**：缓存失序分组，等待缺失分组
- **窗口同步**：防止序号空间重用问题

## 五、面向连接运输：TCP协议

### 5.1 TCP连接管理

#### 5.1.1 连接建立（三次握手）

```
客户端 → SYN=1, seq=x → 服务器
客户端 ← SYN=1, ACK=1, seq=y, ack=x+1 ← 服务器
客户端 → ACK=1, seq=x+1, ack=y+1 → 服务器
```

#### 5.1.2 连接释放（四次挥手）

```
主动方 → FIN=1 → 被动方
主动方 ← ACK=1 ← 被动方
主动方 ← FIN=1 ← 被动方
主动方 → ACK=1 → 被动方
```
### 四次挥手

#### 为什么需要四次挥手？

TCP 连接是**全双工**的，这意味着数据可以在两个方向上独立传输。因此，关闭连接时，每个方向都必须单独关闭。四次挥手的过程可以理解为分别关闭这两个独立的信道。

- **第一次 + 第二次挥手**：关闭从 **客户端 -> 服务器** 的数据通道。
- **第三次 + 第四次挥手**：关闭从 **服务器 -> 客户端** 的数据通道。

#### 四次挥手的详细步骤（假设由客户端主动发起关闭）

##### 第一次挥手：FIN （客户端 -> 服务器）

1. **触发条件**：客户端应用程序调用 `close()` 函数，决定要关闭连接。
2. **动作**：客户端 TCP 向服务器发送一个特殊的 TCP 报文段。这个报文段的**首部标志位 `FIN` (Finish) 被设置为 1**。同时，该报文段会包含一个序号 `seq = x`（x 是客户端之前传送的数据的最后一个字节的序号加 1）。
3. **状态变化**：发送完 FIN 报文段后，客户端进入 **`FIN-WAIT-1`** 状态，等待服务器的确认。

> **含义**：客户端告诉服务器：“我（客户端）没有数据要发送给你了，我想关闭我这个方向的连接。”

##### 第二次挥手：ACK （服务器 -> 客户端）

1. **触发条件**：服务器收到客户端发来的 FIN 报文段。
2. **动作**：服务器 TCP 收到 FIN 后，会立即发送一个**确认 (ACK) 报文段**。这个报文段的**确认号字段 `ack = x + 1`**。
3. **状态变化**：发送完 ACK 后，服务器进入 **`CLOSE-WAIT`** 状态。

> **含义**：服务器告诉客户端：“我收到了你的关闭请求，我同意你关闭。”

**此时，从客户端到服务器方向的连接已经关闭了**。客户端不能再向服务器发送数据，但连接的另一半（服务器到客户端）仍然是打开的。服务器可能还有未发送完的数据需要继续发送给客户端。这种状态称为 **“半关闭”** 状态。

##### 第三次挥手：FIN （服务器 -> 客户端）

1. **触发条件**：当服务器也完成了所有数据的发送后（例如，服务器应用程序也调用 `close()`），它也需要关闭自己这个方向的连接。
2. **动作**：服务器 TCP 向客户端发送一个 **FIN 报文段**（`FIN` 标志位设为 1）。这个报文段有自己的序号 `seq = y`（y 是服务器之前传送的数据的最后一个字节的序号加1）。通常，这个报文段也会包含对客户端 FIN 的确认，即 `ack = x + 1`。
3. **状态变化**：发送完 FIN 报文段后，服务器进入 **`LAST-ACK`** （最后确认）状态，等待客户端的最终确认。

> **含义**：服务器告诉客户端：“我（服务器）这边的数据也发完了，我也要关闭连接了。”

##### 第四次挥手：ACK （客户端 -> 服务器）

1. **触发条件**：客户端收到服务器发来的 FIN 报文段。
2. **动作**：客户端必须对服务器的 FIN 进行确认。它发送一个 **ACK 报文段**，其中确认号 `ack = y + 1`。
3. **状态变化**：发送完 ACK 后，客户端进入 **`TIME-WAIT`** （时间等待）状态。**请注意，客户端并不会立即释放资源，而是会等待一段时间（2MSL，下文解释）后，才进入 `CLOSED` 状态并释放所有连接资源。**
4. **服务器端**：服务器一旦收到这个最终的 ACK，它就认为连接已完全关闭。它立即进入 **`CLOSED`** 状态，并释放所有资源。

> **含义**：客户端告诉服务器：“我收到了你的关闭请求，确认完毕。我们都可以关闭了。”

---

#### 关键点与常见问题

##### 1. 为什么是四次，而不是三次？

因为服务器的第二次挥手 (ACK) 和第三次挥手 (FIN) **不能合并**。在第二次挥手后，服务器可能还需要处理并发送一些剩余数据，所以 ACK 和 FIN 的发送是分开的。如果服务器没有剩余数据要发送，某些实现可能会将 ACK 和 FIN 合并，但这并非标准行为。从理论上讲，TCP 规范要求它们是两个独立的步骤。

##### 2. `TIME-WAIT` 状态是什么？为什么需要等待 2MSL？

这是四次挥手中最容易困惑但非常重要的部分。

- **MSL**：最大报文段生存时间，是任何 IP 数据报能在网络上存活的最长时间。
- **持续时间**：`TIME-WAIT` 状态的持续时间通常设置为 **2MSL**。

**存在两个主要原因：**

1. **可靠地终止连接**：确保最后一个 ACK 能到达服务器。如果这个 ACK 在网络中丢失，服务器（处于 `LAST-ACK` 状态）会因超时而重传它的 FIN。客户端在 `TIME-WAIT` 状态下收到这个重传的 FIN 后，会重发 ACK 并重置 2MSL 定时器。如果没有 `TIME-WAIT` 状态，客户端在发送 ACK 后立即关闭，若 ACK 丢失，服务器将永远处于 `LAST-ACK` 状态，无法正常关闭。
2. **让旧连接的报文段在网络中消逝**：防止之前连接的、延迟到达的报文段被新的、具有相同四元组（源IP、源端口、目的IP、目的端口）的连接错误地接收。等待 2MSL 可以确保所有属于当前连接的报文段都在网络中消失。

##### 3. 如果双方同时发起关闭会怎样？

这种情况会发生“同时关闭”。双方都会发送 FIN 并进入 `FIN-WAIT-1` 状态。在收到对方的 FIN 后，它们会发送 ACK 并进入 `CLOSING` 状态，最后在收到对方的 ACK 后都进入 `TIME-WAIT` 状态。最终连接也能正常关闭。

希望这个详细的解释能帮助你彻底理解 TCP 的四次挥手！

### 5.2 TCP报文段结构

```
 0                   16                   31
|源端口号           |目的端口号           |
|序号               |确认号               |
|首部长度|保留|标志位|接收窗口            |
|检验和             |紧急指针            |
|选项（可选）       |填充                |
|数据（可选）                            |
```

**标志位含义**：

- **URG**：紧急指针有效
- **ACK**：确认号有效
- **PSH**：推送功能
- **RST**：复位连接
- **SYN**：同步序号
- **FIN**：结束连接

### 5.3 TCP可靠数据传输机制

#### 5.3.1 序号与确认机制

- **字节流编号**：序号基于字节流编号，不是报文段编号
- **累积确认**：确认号表示期望接收的下一个字节序号
- **选择确认**：通过TCP选项支持选择性确认

#### 5.3.2 超时与重传

- **RTT估计**：采用指数加权移动平均(EWMA)算法
    - **EstimatedRTT** = $(1-α)×EstimatedRTT + α×SampleRTT$
    - **DevRTT** = $(1-β)×DevRTT + β×|SampleRTT - EstimatedRTT|$
    - **TimeoutInterval** =$EstimatedRTT + 4×DevRTT$

#### 5.3.3 快速重传机制

- **重复ACK**：收到3个重复ACK立即重传，不等待超时
- **快速恢复**：重传后进入拥塞避免而非慢启动

### 5.4 TCP流量控制

#### 5.4.1 滑动窗口机制

- **接收窗口(rwnd)**：接收方通告的可用缓存空间
- **发送窗口**：min(拥塞窗口cwnd, 接收窗口rwnd)
- **零窗口探测**：当rwnd=0时发送单字节探测报文

#### 5.4.2 糊涂窗口综合征避免

- **接收方策略**：等待缓存有足够空间再通告新窗口
- **发送方策略**：等待有足够数据再发送

## 六、拥塞控制原理与机制

### 6.1 拥塞原因与代价

#### 6.1.1 拥塞原因

- **缓存溢出**：路由器缓存有限导致分组丢失
- **多路竞争**：多条连接共享瓶颈链路

#### 6.1.2 拥塞代价

- **时延增加**：排队时延随负载增加而增加
- **吞吐量下降**：重传导致有效吞吐量降低
- **资源浪费**：重复传输消耗网络资源

### 6.2 TCP拥塞控制算法

#### 6.2.1 加性增乘性减(AIMD)

- **加性增**：每个RTT将cwnd增加1个MSS
- **乘性减**：发生丢包时将cwnd减半

#### 6.2.2 拥塞控制状态机
```
流程图：TCP拥塞控制状态转换
慢启动 → cwnd≥ssthresh → 拥塞避免
慢启动 ← 超时事件 ← 拥塞避免
拥塞避免 → 3个重复ACK → 快速恢复
```

#### 6.2.3 具体算法细节

**慢启动阶段**：

- 初始cwnd = 1 MSS
- 每收到一个ACK，cwnd增加1 MSS（指数增长）
- 当cwnd ≥ ssthresh时进入拥塞避免

**拥塞避免阶段**：

- 每RTT将cwnd增加1 MSS（线性增长）
- 当检测到丢包时，ssthresh = max(cwnd/2, 2 MSS)

**快速恢复阶段**：

- 重传丢失报文段后，执行拥塞避免而非慢启动

### 6.3 拥塞控制演进

#### 6.3.1 TCP Tahoe

- 包含慢启动和拥塞避免
- 任何丢包都导致cwnd重置为1 MSS

#### 6.3.2 TCP Reno

- 增加快速重传和快速恢复
- 3个重复ACK触发快速恢复，超时仍重置cwnd

#### 6.3.3 TCP NewReno

- 改进快速恢复，处理多个分组丢失
- 仅当所有丢失分组被确认后才退出快速恢复

#### 6.3.4 TCP CUBIC

- 使用立方函数代替线性增长
- 更公平的带宽共享，适合高速网络

## 七、运输层功能演化与新技术

### 7.1 明确拥塞通告(ECN)

- **网络辅助拥塞控制**：路由器显式标记拥塞状态
- **IP层支持**：使用IP首部ECN字段
- **端系统响应**：根据ECN标记调整发送速率

### 7.2 基于时延的拥塞控制

- **时延测量**：使用RTT变化作为拥塞信号
- **BBR算法**：谷歌提出的基于瓶颈带宽和RTT的算法

### 7.3 QUIC协议

- **应用层运输协议**：基于UDP实现可靠传输
- **多路复用**：在单个连接上复用多个数据流
- **0-RTT连接建立**：减少握手时延
- **前向纠错**：提高传输可靠性

## 八、关键概念对比分析

### 8.1 流量控制 vs 拥塞控制

|特性|**流量控制**|**拥塞控制**|
|---|---|---|
|**控制目标**|防止接收方缓存溢出|防止网络资源过载|
|**作用范围**|端到端|网络全局|
|**反馈机制**|接收窗口(rwnd)|丢包事件、时延增加|
|**实现方式**|滑动窗口|AIMD算法|

### 8.2 可靠数据传输协议对比

|协议|窗口大小|确认机制|重传策略|效率|
|---|---|---|---|---|
|**停等协议**|1|单个确认|超时重传|低|
|**GBN**|N|累积确认|回退N步重传|中|
|**SR**|N|选择确认|选择重传|高|

### 8.3 TCP拥塞控制算法比较

|算法|核心思想|优点|缺点|
|---|---|---|---|
|**Tahoe**|慢启动+拥塞避免|简单稳定|效率较低|
|**Reno**|增加快速恢复|响应速度快|多个丢包处理差|
|**NewReno**|改进快速恢复|处理多个丢包|实现复杂|
|**CUBIC**|立方增长函数|高速网络性能好|公平性问题|

## 九、实践应用案例

### 9.1 Web服务器TCP连接管理

- **持久连接**：多个HTTP请求共享同一TCP连接
- **连接池**：复用已建立连接减少握手开销
- **负载均衡**：根据连接数分配服务器负载

### 9.2 实时音视频传输

- **UDP优先**：低时延比可靠性更重要
- **自适应码率**：根据网络状况调整传输质量
- **前向纠错**：添加冗余数据提高容错能力

### 9.3 大数据传输优化

- **窗口缩放**：支持大于64KB的窗口大小
- **选择性确认**：减少不必要重传
- **带宽延迟积**：优化窗口大小匹配网络容量

---

**本章核心总结**：

1. 运输层为应用进程提供逻辑通信服务，核心是TCP和UDP协议
2. TCP通过序号、确认、重传、流量控制和拥塞控制实现可靠性
3. 拥塞控制是TCP的关键特性，采用AIMD算法平衡公平性和效率
4. 新技术如ECN、QUIC正在推动运输层功能持续演化

**下一章预告**：第4章将深入网络层，研究IP协议、路由算法和网络层设备工作原理。

### 附录：第3章英文缩写与汉语意思对照表

| 英文缩写         | 英文全称                                      | 汉语意思       |
| ------------ | ----------------------------------------- | ---------- |
| **TCP**      | Transmission Control Protocol             | 传输控制协议     |
| **UDP**      | User Datagram Protocol                    | 用户数据报协议    |
| **MSS**      | Maximum Segment Size                      | 最大报文段大小    |
| **RTT**      | Round-Trip Time                           | 往返时间       |
| **ACK**      | Acknowledgment                            | 确认         |
| **NAK**      | Negative Acknowledgment                   | 否定确认       |
| **ARQ**      | Automatic Repeat Request                  | 自动重传请求     |
| **GBN**      | Go-Back-N                                 | 回退N步       |
| **SR**       | Selective Repeat                          | 选择重传       |
| **cwnd**     | Congestion Window                         | 拥塞窗口       |
| **rwnd**     | Receive Window                            | 接收窗口       |
| **ssthresh** | Slow Start Threshold                      | 慢启动阈值      |
| **AIMD**     | Additive Increase Multiplicative Decrease | 加性增乘性减     |
| **ECN**      | Explicit Congestion Notification          | 明确拥塞通告     |
| **QUIC**     | Quick UDP Internet Connections            | 快速UDP互联网连接 |
| **FSM**      | Finite-State Machine                      | 有限状态机      |
| **DoS**      | Denial of Service                         | 拒绝服务       |
| **DDoS**     | Distributed Denial of Service             | 分布式拒绝服务    |
| **SYN**      | Synchronize                               | 同步         |
| **FIN**      | Finish                                    | 结束         |
| **RST**      | Reset                                     | 复位         |
| **PSH**      | Push                                      | 推送         |
| **URG**      | Urgent                                    | 紧急         |