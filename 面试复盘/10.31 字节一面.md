以下是根据你提供的面试录音内容，**完整整理的“问题-回答”对照表**，并为每一个技术问题补充了**标准、准确的技术答案（参考答案）**，以便用于后续评估求职者表现或进行培训指导。

---

### ✅ 面试全程问答整理 + 标准答案

---

#### **1. 自我介绍**

> **面试官：** OK，那先做下自我介绍吧。  
> **求职者：** 嗯，面试官你好，我是来自大连理工大学计算机科学技术专业的大三学生张晓文。嗯，我自学了Java后端开发的技术。嗯嗯，掌握Java基础，了解GVM和并发高并发，然后掌呃掌握。Spring Boot, MyBits, Redis, MySQL等一些主流技术，然后在网络上寻找开源项目，制作了自己的两个项目，就这样。

✅ **点评：**
- 内容基本清晰，但表达略显紧张、重复多（如“嗯”、“呃”），建议提前练习简洁流畅的自我介绍。
- “GVM”应为“JVM”，可能是口误。
- “MyBits”应为“MyBatis”。

---

#### **2. 是否可以记录面试过程？**

> **面试官：** OK，那个面试过程中我可能会打字记录一些表现情况，这个没有问题吧？  
> **求职者：** 没有。

✅ **点评：** 正常流程确认，无问题。

---

#### **3. 请介绍一下 HTTP 协议是什么？**

> **求职者回答：**  
> HTTP协议属于是应用层的协议，它是从客户端发出一个请求报文，到服务端获得一个响应报文。服务端响应中包括网站内容等信息。HTTP基于TCP提供可靠传输。经过多个版本迭代，在最初始版本会同时发起多个TCP连接；但在HTTP/1.0改进为可多路复用，在一个请求中传输多个数据。

❌ **错误点分析：**
- 将 **HTTP/1.1 的持久连接与多路复用** 错误地归于 HTTP/1.0。
- 实际上：
  - HTTP/1.0 默认每个请求建立一次 TCP 连接（非持久）；
  - HTTP/1.1 才默认使用持久连接，并支持管道化（pipeline），但仍存在队头阻塞；
  - 真正的“多路复用”是在 **HTTP/2** 中实现的。

✅ **标准答案：**

> HTTP（HyperText Transfer Protocol）是一种**应用层协议**，用于在客户端（如浏览器）和服务器之间传输超文本数据。
>
> - 基于 **TCP/IP** 协议，保证可靠传输；
> - 使用 **请求-响应模型**：客户端发送请求报文 → 服务端返回响应报文；
> - 是**无状态协议**（不保存上下文），可通过 Cookie、Session 或 JWT 维持状态；
> - 支持多种方法（GET、POST 等）、状态码（200、404、500 等）；
> - 版本演进：
>   - HTTP/1.0：每次请求新建 TCP 连接；
>   - HTTP/1.1：引入持久连接（keep-alive）、管道化；
>   - HTTP/2：二进制分帧、多路复用、头部压缩；
>   - HTTP/3：基于 QUIC 协议，解决队头阻塞问题。

---

#### **4. HTTP 协议有哪些常见方法？

> **求职者回答：**  
> get 方法（获取用户信息）、post 方法（上传信息）、delete 方法（删除信息）、update 方法用来更新信息。

⚠️ **部分正确，但有术语错误：**
- update 不是 HTTP 方法名，正确的叫法是 **PUT 或 PATCH**。

✅ **标准答案：**

常见的 HTTP 方法包括：

| 方法   | 含义 |
|--------|------|
| `GET`    | 获取资源（安全且幂等） |
| `POST`   | 提交数据，创建新资源（非幂等） |
| `PUT`    | 更新整个资源（幂等） |
| `PATCH`  | 局部更新资源（通常非幂等） |
| `DELETE` | 删除资源（幂等） |
| `HEAD`   | 只获取响应头（不返回 body） |
| `OPTIONS`| 查询支持的方法 |

---

#### **5. GET 和 POST 最核心的区别是什么？**

> **求职者回答：**  
> post 主要是客户端向服务端上传信息，get 更多是从服务端拉取信息。get 在 URL 传参，post 可以通过 JSON 传更多数据。

✅ **优点：** 能说出参数传递方式不同（URL vs body）。  
❌ **不足：** 对语义理解不够深入，未提及其他关键区别。

✅ **标准答案：**

| 区别点      | GET                      | POST                |
| -------- | ------------------------ | ------------------- |
| **语义**   | 获取资源                     | 提交数据                |
| **数据位置** | 在 URL 查询字符串中（?key=value） | 在请求体（Request Body）中 |
| **安全性**  | 安全方法（不应改变服务器状态）          | 非安全方法（常用于修改数据）      |
| **幂等性**  | 幂等（多次执行效果相同）             | 非幂等（可能多次创建资源）       |
| **缓存**   | 可被浏览器缓存                  | 一般不可缓存              |
| **长度限制** | 受 URL 长度限制（约 2KB~8KB）    | 几乎无限制               |
| **可见性**  | 参数暴露在地址栏，不安全             | 相对安全（不在地址栏显示）       |
|          |                          |                     |

📌 **核心区别总结：**
> **GET 是“读操作”，强调获取；POST 是“写操作”，强调提交或创建。**

---

#### **6. 什么是 TCP 协议？它有什么特点？**

> **求职者回答：**  
> TCP 是信息传输控制协议，提供可靠传送，通过流量控制、拥塞控制实现可靠性。

✅ **基本正确，但表述不严谨。**

✅ **标准答案：**

TCP（Transmission Control Protocol）是**传输层协议**，提供面向连接、可靠的字节流服务。

**主要特点：**

1. **面向连接：** 通信前需三次握手建立连接；
2. **可靠传输：**
   - 序号与确认机制（ACK）
   - 超时重传
   - 数据校验
3. **流量控制：** 使用滑动窗口机制防止接收方溢出；
4. **拥塞控制：** 慢启动、拥塞避免、快重传、快恢复；
5. **全双工通信：** 双方可同时收发数据；
6. **字节流模式：** 不保留消息边界（需应用层处理粘包问题）。

---

#### **7. TCP 是如何建立连接的？（三次握手）**

> **求职者回答：**  
> 通过“三次挥手”建立连接：客户端发请求 → 服务端回 ACK + SYN → 客户端再回 ACK。

❌ **严重错误：**
- 把“三次握手”说成“三次挥手”；
- “挥手”是断开连接的过程（四次挥手）。

✅ **标准答案：**

TCP 通过 **三次握手（Three-way Handshake）** 建立连接：

1. **第一次：** 客户端 → 服务端  
   发送 `SYN=1`, seq=x （同步标志位，表示请求建立连接）

2. **第二次：** 服务端 → 客户端  
   回复 `SYN=1, ACK=1`, seq=y, ack=x+1

3. **第三次：** 客户端 → 服务端  
   回复 `ACK=1`, seq=x+1, ack=y+1

此时双方进入 ESTABLISHED 状态，可开始数据传输。

📌 **目的：** 同步初始序列号，确保双向通道可用。

---

#### **8. 进程和线程的区别？**

> **求职者回答：**  
> 进程是计算机会分配一大块内存来完成任务。线程是进程下的小任务。不同进程独立，通信复杂；同进程的线程易互相干扰。

✅ **基本正确，有一定理解。**

✅ **标准答案：**

| 对比项 | 进程（Process） | 线程（Thread） |
|--------|------------------|----------------|
| 定义 | 程序的一次执行过程，系统资源分配单位 | 进程内的执行单元，CPU调度的基本单位 |
| 地址空间 | 拥有独立的地址空间 | 共享所属进程的地址空间 |
| 资源开销 | 创建销毁开销大 | 开销小 |
| 通信方式 | 需 IPC（管道、共享内存、消息队列等） | 可直接访问全局变量、堆数据 |
| 独立性 | 独立运行，互不影响 | 一个线程崩溃可能导致整个进程崩溃 |
| 切换成本 | 较高 | 较低 |

📌 **一句话总结：**
> 进程是资源分配的最小单位，线程是 CPU 调度的最小单位。一个进程可包含多个线程。

---

#### **9. 如何避免线程之间的互相干扰？**

> **求职者回答：**  
> 加事务处理或者加锁。

✅ **方向正确，提到“加锁”。**

✅ **标准答案：**

为了避免多线程并发访问共享资源导致的数据不一致（如竞态条件），常用手段如下：

1. **互斥锁（Mutex / synchronized）：** 同一时间只允许一个线程访问临界区；
2. **读写锁（ReadWriteLock）：** 读共享、写独占；
3. **原子类（AtomicInteger 等）：** 利用 CAS 实现无锁并发；
4. **volatile 关键字：** 保证可见性和禁止指令重排（不能保证原子性）；
5. **ThreadLocal：** 为每个线程提供独立副本；
6. **使用线程安全容器（ConcurrentHashMap、CopyOnWriteArrayList）；**
7. **合理设计，减少共享状态。**

---

#### **10. 在什么场景下用过锁？举例说明。**

> **求职者回答：**  
> 秒杀活动中防止优惠券超卖。当多个线程检查库存时，若都看到还有库存，但未加锁就减库存，会导致负库存。因此要在查询和扣减之间加锁。

✅ **很好！给出了真实业务场景（秒杀），逻辑清晰。**

✅ **标准答案示例：**

典型场景：**高并发下的库存超卖问题（如秒杀、抢购）**

- 多个用户同时请求购买商品；
- 若不加锁，可能出现：
  1. 用户A查库存 > 0；
  2. 用户B也查库存 > 0；
  3. A/B 同时扣减库存 → 导致库存变为负数。

**解决方案：**
- 使用分布式锁（如 Redis 的 SETNX）或数据库行锁（SELECT FOR UPDATE）；
- 控制对“库存检查 + 扣减”这一临界区的串行化访问。

---

#### **11. 这种锁属于悲观锁还是乐观锁？**

> **求职者回答：**  
> 属于悲观锁，因为我们预设一定会发生冲突。

✅ **完全正确！**

✅ **标准答案：**

- **悲观锁：** 假设一定会发生并发冲突，因此在整个操作期间锁定资源（如数据库 `SELECT ... FOR UPDATE`，Redis 分布式锁）。
  - 适合写操作频繁、冲突概率高的场景。
- **乐观锁：** 假设不会发生冲突，只在提交时检查是否有其他修改（如版本号 version 字段、CAS）。
  - 适合读多写少的场景。

📌 在秒杀场景中，因竞争激烈，通常采用**悲观锁策略**更稳妥。

---

#### **12. 这个锁是怎么实现的？用了 Redis 的 setnx？**

> **求职者回答：**  
> 用 Redis 的 SetNx，以库存作为标识，申请锁，成功则处理库存更新。

✅ **思路正确，但描述模糊。**

✅ **标准答案（Redis 分布式锁实现要点）：**

使用 `SETNX key value`（SET if Not eXists）实现简单分布式锁：

```bash
# 尝试获取锁
SETNX lock:stock_1001 "thread_001"
EXPIRE lock:stock_1001 10  # 必须设置过期时间防死锁
```

**关键点：**
1. **SETNX + EXPIRE 要原子执行** → 推荐使用：
   ```bash
   SET lock:stock_1001 "thread_001" NX EX 10
   ```
2. **value 应唯一（如 UUID）**，便于释放锁时验证所有权；
3. **释放锁时要用 Lua 脚本保证原子性：**
   ```lua
   if redis.call("get", KEYS[1]) == ARGV[1] then
       return redis.call("del", KEYS[1])
   else
       return 0
   end
   ```

⚠️ 注意：生产环境推荐使用 Redisson 或 Redlock 算法提高可靠性。

---

#### **13. 为什么用 SETNX 而不是 SET？两者区别？**

> **求职者回答：**  
> set nx 可以设置过期时间，逻辑过期时间。

❌ **错误：** `SET` 也可以设置过期时间（EX/PX 参数）。

✅ **标准答案：**

| 命令 | 作用 |
|------|------|
| `SET key value [EX seconds] [PX milliseconds]` | 设置键值，可选过期时间 |
| `SETNX key value` | 当 key 不存在时才设置（即“Set If Not Exists”） |

🔹 **核心区别：**
> `SETNX` 是**带条件的写入操作**，只有当 key 不存在时才会设置成功，返回 1；否则失败，返回 0。

📌 正是因为这个特性，`SETNX` 才能用来实现**互斥锁**——多个线程尝试设置同一个 key，只有一个能成功，相当于“抢到锁”。

💡 更优做法：使用 `SET key value NX EX max-lock-time` 实现原子性的加锁。

---

#### **14. Redis 是什么？为什么快？**

> **求职者回答：**  
> Redis 是非关系型数据库，速度快因为数据存在内存中，K-V 结构，哈希查找 O(1)。

✅ **答出了两个核心原因：内存存储 + 哈希结构。**

✅ **标准答案扩展：**

Redis（Remote Dictionary Server）是一个开源的**内存型键值数据库**，支持字符串、哈希、列表、集合等多种数据结构。

**为什么快？主要原因：**

1. **纯内存操作：** 数据存在 RAM 中，避免磁盘 I/O 延迟；
2. **高效的数据结构：**
   - String：简单动态字符串（SDS）
   - Hash：ziplist 或 hashtable
   - List：quicklist（压缩链表 + 链表）
   - Set/Sorted Set：intset / skiplist
3. **单线程模型 + I/O 多路复用（epoll/kqueue）：**
   - 避免上下文切换和锁竞争；
   - 单线程处理命令，顺序执行，保证原子性；
4. **C 语言编写，底层优化良好；**
5. **网络模型高效：** 使用 Reactor 模式处理大量并发连接。

📌 总结：**内存 + 单线程 + I/O 多路复用 + 精巧数据结构 = 极致性能**

---

#### **15. 有没有从底层了解 Redis 为什么这么快？除了内存和哈希之外还有什么？**

> **求职者回答：**  
> 不太了解。

❌ **未能深入，错失加分机会。**

✅ **补充知识点（见上题）：**
- 单线程避免锁竞争；
- I/O 多路复用支持高并发；
- 数据结构针对不同大小自动切换（如 ziplist → hashtable）；
- 所有操作都是 O(1) 或 O(log N) 级别。

---

#### **16. 什么是 JWT？登录流程？**

> **求职者回答：**  
> JWT 是一种加密算法或令牌。用户登录后，后端生成 token 存入数据库或 Redis，返回给前端；之后每次请求带上 token，后端验证是否合法。

❌ **混淆了 Session 和 JWT 的机制！**

> ⚠️ 描述的是 **基于 Session 的 Token 认证**，而不是 **JWT 的无状态认证**。

✅ **标准答案：**

JWT（JSON Web Token）是一种开放标准（RFC 7519），用于在各方之间安全传输信息。

**结构组成（三段式 Base64 编码）：**

```
Header.Payload.Signature
```

- **Header：** 类型和签名算法（如 HMAC SHA256）
- **Payload：** 包含 claims（用户ID、角色、过期时间等）
- **Signature：** 对前两部分用密钥签名，防止篡改

**JWT 登录流程：**

1. 用户提交用户名密码；
2. 服务端验证通过后，生成 JWT（不含存储）；
3. 返回 JWT 给客户端（通常放在 Authorization header）；
4. 客户端后续请求携带 JWT；
5. 服务端收到后验证签名有效性及是否过期；
6. 解析 payload 获取用户身份，无需查库。

✅ **优势：**
- 无状态：服务端不存储 session，适合分布式系统；
- 可跨域使用；
- 自包含：token 本身含用户信息。

🚫 **注意：**
- JWT 一旦签发，在过期前无法主动失效（除非加黑名单）；
- 敏感信息不要放在 payload 中；
- 必须使用 HTTPS 传输。

---

#### **17. 后台权限控制是如何实现的？**

> **求职者回答：**  
> 管理员登录后可以管理菜品，起卖停卖、更新信息。

❌ **只是功能描述，未说明技术方案。**

✅ **标准答案（RBAC 模型）：**

常见权限控制方案：**RBAC（Role-Based Access Control）**

1. **用户（User）** 拥有一个或多个 **角色（Role）**（如管理员、运营、客服）；
2. **角色** 拥有若干 **权限（Permission）**（如“添加菜品”、“删除订单”）；
3. 权限绑定到具体接口（URL + Method）；
4. 拦截器/过滤器检查当前用户是否有对应权限；
5. 常结合 Spring Security / Shiro 实现。

📌 示例：
- 请求 `/api/admin/dishes/delete` → 拦截器检查用户是否具有 `dish:delete` 权限；
- 若无，则返回 403 Forbidden。

---

#### **18. 了解 MySQL 的事务吗？**

> **求职者回答：**  
> 有点忘记了，不好意思。

❌ **未作答，基础知识缺失。**

✅ **标准答案：**

MySQL 事务是一组 SQL 操作的逻辑单元，要么全部成功，要么全部失败回滚。

**四大特性（ACID）：**

| 特性 | 含义 |
|------|------|
| **A - 原子性（Atomicity）** | 事务是最小单位，不可分割，要么全执行，要么全不执行 |
| **C - 一致性（Consistency）** | 事务前后，数据库从一个一致状态变到另一个一致状态 |
| **I - 隔离性（Isolation）** | 并发事务之间互不干扰 |
| **D - 持久性（Durability）** | 一旦提交，数据永久保存 |

**隔离级别：**

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
|---------|------|------------|-------|
| 读未提交（Read Uncommitted） | ✅ | ✅ | ✅ |
| 读已提交（Read Committed） | ❌ | ✅ | ✅ |
| 可重复读（Repeatable Read）<br>（MySQL 默认） | ❌ | ❌ | ⚠️（InnoDB 通过 MVCC 解决） |
| 串行化（Serializable） | ❌ | ❌ | ❌ |

📌 事务相关命令：
```sql
START TRANSACTION;
-- 多条SQL语句
COMMIT; -- 提交
ROLLBACK; -- 回滚
```

---

### 📊 综合评价与建议

| 维度 | 评分（满分5分） | 评语 |
|------|------------------|------|
| 技术广度 | ⭐⭐⭐☆☆（3.5） | 涉及 Java、Spring Boot、MySQL、Redis、JWT 等主流技术栈，具备一定知识面 |
| 技术深度 | ⭐⭐☆☆☆（2.0） | 多数概念停留在表面，对底层原理掌握不足（如 TCP、Redis、JWT） |
| 表达能力 | ⭐⭐☆☆☆（2.0） | 表达不流畅，口头禅多（“嗯”、“呃”），影响沟通效率 |
| 项目理解 | ⭐⭐⭐☆☆（3.0） | 能讲出秒杀场景的锁问题，有一定实战意识，但细节实现描述不清 |
| 基础扎实度 | ⭐⭐☆☆☆（2.0） | 对进程线程、事务、网络协议等基础概念掌握不牢 |

---

### ✅ 改进建议

1. **加强基础知识复习：**
   - 深入理解操作系统、计算机网络、数据库的核心概念；
   - 推荐书籍：《图解HTTP》《计算机网络：自顶向下》《高性能MySQL》

2. **提升表达清晰度：**
   - 练习结构化表达：总—分—总结构；
   - 减少“嗯”、“呃”等填充词，可适当停顿思考。

3. **深入项目细节：**
   - 明确自己项目的架构、难点、解决方案；
   - 能画出简单的流程图或时序图解释关键逻辑。

4. **区分相似概念：**
   - 如 Session vs JWT、悲观锁 vs 乐观锁、SET vs SETNX；
   - 避免混淆术语。

5. **模拟面试训练：**
   - 找同学或导师进行模拟面试，锻炼临场反应和表达能力。

---

📝 **结论：**
该同学具备一定的自学能力和项目经验，适合作为初级 Java 后端实习生培养对象。但目前技术水平尚浅，需进一步夯实基础、提升表达能力和系统思维，方可胜任正式岗位。

--- 

如需将此文档导出为 Word/PDF 用于教学或反馈，请告知，我可以帮你格式化输出。